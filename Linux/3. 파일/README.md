# 파일

파일은 이름이 있습니다.  
기본적으로 이 파일이름은 앞에 경로가 있다고 생각하면 됩니다.  
예를들어 ABC라는 파일이라고 있다고 치면 /usr/local/ABC 라는 파일이 있는것입니다.  

운영체제는 하드웨어 위에 올라가는 최초의 소프트웨어가 운영체제입니다.  
그렇기 때문에 운영체제는 하드웨어의 자원들을 관리, 감독해야합니다.  
여기에는 디스크도 포함입니다. 디스크안에있는 수많은 파일들에 대해서 운영체제가 관리를해야 애플리케이션이 운영체제를 통해서 파일들에 접근해서 쓰기,읽기 등을 하게 됩니다.  
시스템상에서는 디스크가 여러개인 경우가 있고, 하나의 디스크를 잘라서 여러개로 인식하게할 수도 있습니다.  
이러한 파일에 관련된 여러가지 행위들을 관리/감독하는 하나의 계층이 있습니다.  
이 계층을 파일 시스템이라고 합니다.  
파일시스템은 운영체제의 일부이기 때문에 운영체제와 디스크 사이에 있다고 생각하면 됩니다.  

<br/><br/>

# 파일 시스템

파일을 관리하기 위한 시스템이다.  
EXT 2, 3, 4, XFS 등이 있다.

리눅스와 윈도우의 차이점은 리눅스는 root 디렉토리 하위에 있지만 윈도우는 C,D,E 등 하위에 있게 됩니다.  
윈도우는 C,D 디스크에 따로 경로가 표시되지만 리눅스에 기존에 있던 하드디스크외에 하나를 추가한다면 경로가 기존의 루트 디렉토리 밑에 하나의 디렉토리를 만들고 그 디렉토리 밑으로 마운트를 시켜줘야합니다.  
그래서 최종 경로는 /새로만든디렉토리/... 이렇게 마운트가 됩니다.  

<br/><br/>

# 파일의 종류

| 파일의 종류         | 설명               |
|-----------------|----------------------|
| 일반 파일(regular file)    | 말 그대로 일반 파일.<br/> 텍스트 파일이나 동영상 파일 등이 일반  파일에 포함됩니다.         |
| 디렉터리(directory    | 디렉터리도 파일의 한 종류입니다. 윈도우의 폴더와 같은 개념이다.         |
| 심볼릭 링크 파일(symbolic link file    | 어떤 다른 파일을 가리키는 파일이다. 윈도우의 바로가기와 같은 개념이다.         |
| 블록 디바이스 파일(block device file)    |  블록 디바이스를 제어하기 위한 파일        |
| 문자 디바이스 파일(character device file)    |  문자 디바이스를 제어하기 위한 파일        |
| 파이프 파일(pipe file)    | 파이프를 나타내는 파일, 프로세스간 통신에 사용됨         |
| 소켓(socket)    |  소켓을 나타내는 파일. 프로세스간 통신에 사용됨        |


하드웨어가 잘 동작하기 위해서는 전원만 들어온다고 잘 동작하지는 않습니다.  
이 하드웨어는 운영체제와 연결이 되어 있습니다.  
하드웨어를 잘 관리하기위한 소프트웨어가 디바이스 드라이버입니다.  
이 디바이스 드라이버는 하드웨어와 운영체제사이?, 운영체제와 동일한 위치하고 싶습니다.  
디바이스 드라이버는 운영체제와 협업을 합니다.  이 때 디바이스 드라이버는 운영체제와 하드웨어 사이에서만 일하는것이 아니고 애플리케이션과도 협업을 하는데 이때 필요한것이 디바이스 파일입니다.  
이 디바이스 파일은 디바이스 드라이버를 제어를 해야하는데 애플리케이션이 그 명령을 내릴 수 도 있습니다.  
블락 디바이스는 어떤 영역자체를 공유할때는 블락 디바이스를 사용하고 문자 디바이스는 키보드처럼 순차적인 동작에 대해서 처리할때 사용합니다.  

<br/><br/>

# 디렉터리

| 디렉터리          | 설명               |
|-----------------|----------------------|
|/           | 루트 디렉터리. 모든 디렉터리의 최상위 부모입니다. |
|/bin        | 모든 사용자가 사용할 수 있는 여러가지 실행 파일 위치  |
|/sbin       | 시스템 관리자 권한으로 실행해야 하는 실행 파일 위치 |
|/etc        | 여러가지 설정파일(주의) |
|/lib        | 공유 라이브러리 디렉터리 |
|/home       | 사용자들의 홈 디렉터리 |
|/mnt        | 일시적으로 파일 시스템에 마운트하는 경우 사용하는 디렉터리 |
|/proc, /sys | 시스템 정보를 설정/조회할 수 있는 디렉터리 |
|/tmp        | 임시 디렉터리 |
|/usr        | 사용자가 추가한 실행 파일, 라이브러리 등의 소프트웨어 저장 |
|/dev        | 디바이스 드라이버가 사용하는 디바이스 파일 디렉터리 |


## 디렉터리의 개념
- 현재 작업 디렉터리 (CWD : Current Working Directory)  
프롬포트에서 $ 왼쪽에 있는 경로가 현재 디렉터리이다. 명령어로는 pwd, echo $PWD 입력하면 현재 디렉터리가 출력된다.
- 홈 디렉터리(home directory)  
/home/{계정이름} 입니다.  그렇기 때문에 계정이 다르면 서로 홈 디렉터리를 볼 수 없다.
- 상대 경로 (relative path) vs 절대경로(absolute path)  
리눅스는 루트경로를 시작으로 트리구조로 되어 있다. 그렇기때문에 현재 디렉터리에 대해서 상대경로와 절대경로로 표현할 수 있다. 


<br/><br/>

# 아이노드 (inode)
파일의 실제 데이터가 아니라 해당 파일에 대한 메타데이터들이 저장되어있는 공간이다.  

# 하드링크와 소프트링크
- 하드링크(hard-link) vs 소프트링크(soft-link == symbolic link == symlink)

https://miro.medium.com/v2/resize:fit:628/1*ojVZedoItdtM1OEpl9YatQ.png  
위의 그림을 보고 설명합니다.  
예를 들어 노래 가사를 적어 놓은 파일이 있다고 가정하겠습니다.  
가사에 대한 부분이 파일 데이터입니다. 
이 파일에 연결된 아이노드가 있습니다. 이 아이노드는 파일을 나타내는 메타데이터, 파일의 정보들을 구성하고 있습니다.  
여기서 파일 이름은 아이노드에 포함되어 있지 않습니다.  
파일 네임은 Directory Entry라는곳에 따로 저장 되어 있습니다.  

Directory Entry 에는 파일 이름이 있고 아이노드 포인터가 있어 아이노드와 연결해줍니다.  
그래서 하나의 파일은 name - inode - Data 이렇게 구성되어있습니다.  

소프트링크는 어떠한 파일이 있는데 윈도우에서 바로가기가 있습니다.  
이 실행파일이 hello면 hello의 바로가기 이런식의 이름으로해서 아이콘이 생깁니다.  
사용자가 이 바로가기 파일을 더블 클릭해서 실행하면 실제 파일을 더블클릭해서 실행한것처럼 됩니다.  
리눅스의 소프트링크도 이런 방식입니다.  
리눅스에서는 바로가기가 아니라 소프트링크 파일을 만들 수 있습니다.  
이 파일을 만들때에는 대상이 누구인지 지정하게 되어 있습니다.  
소프트링크는 위에서 말한 아이노드에서 파일 데이터가 아닌 링크데이터가 생기는데 이 링크데이터가 원본 파일의 파일 네임을 가리키게 됩니다.  
그래서 바로가기를 클릭하면 링크데이터를 타고 원본 파일을 찾아 실행되게 됩니다.  

소프트링크는 자기 자신의 파일 네임과 아이노드가 있습니다.  하지만 하드링크는 링크긴 링크인데 대상이 되는 아이노드를 공유를 합니다.  
그래서 파일 이름만 다르지 같은 파일인 셈입니다.  

<br/><br/>

# 파일 다루기

## touch 파일명
파일 만들기

## rm 파일명 
파일 삭제하기

## mv testfile apple
파일 이름 바꾸기
파일의 이름을 바꾸기도 하지만 경로를 바꾸는 것이다.  
mv 원본 파일이름 바꾸고싶은 파일이름

<br/><br/>

# 디렉터리 다루기

## $ mkdir 디렉터리 이름
디렉터리를 만든다.  
디렉터리는 기본적으로 파란색으로 표시된다.  
ls -al
조회해서 맨 앞글자는 파일의 속성을 나타낸다.  
-는 일반 파일 d는 디렉터리를 나타낸다.  

## rmdir 디렉터리/
디렉터리 지우는 명령어이다. 이 명령어는 해당 디렉터리 하위에 파일이 있다면 실패한다.

## rm -r, -R, --recursive 디렉토리명/
이 명령어는 재귀적으로 하위 디렉터리까지 다 지워주는 명령어입니다.  

## rm -rf 디렉토리명/
강제적으로 해당 디렉터리와 하위 디렉터리를 다 지웁니다.

<br/><br/>

# 아이노드와 하드링크
## ls -i, ls -ali
아이노드 링크를 보여준다.  


## 하드링크 만들기
## ln pineaplle hello

## ls -al 명령어 후 숫자는 하드링크의 개수이다.

## stat 파일이름 : 파일을 자세히 보여준다.  
