# 프로세스와 시그널
프로세스가 사전적인 의미로는 처리과정,진행,공정의 의미입니다.  
컴퓨터 프로그래밍에서의 의미는 컴퓨터가 일을 하게 하는 주체를 뜻합니다.  
그래서 컴퓨터 시스템에서는 실행중인 프로그램을 의히합니다.  
시그널은 프로세스에게 알려주는 행위입니다.  

프로그램은 하드디스크에 저장되어있기만 하면됩니다.  
프로세스는 메모리영역에서 작동하기 합니다. 예를 들면 크롬을 실행시킨후 컴퓨터를 껏다키면 실행중이던 크롬이 꺼지는것으로보아 메모리 영역에서 작동중인것을 알 수 있습니다.  그래서 프로세스는 메모리 위에 있는 객체라 이해하면 될 것 같습니다.  
그리고 인텔리제이를 한 번에 2개, 3개를 사용하는것을 예를 들때 프로그램은 하나이고 프로세스는 여러개 실행시킬수 있는것을 알 수 있습니다.  -> 프로그램은 정적, 프로세스는 동적.  
메모리 상의 프로세스는 CPU가 실행시켜줍니다.  
이 프로세스가 담고 있는 해야 할 일을 실행시켜주는것은 CPU입니다.  
CPU는 여러개의 프로세스중에 1번 프로세스를 실행시켜주다가 2번 프로세스를 실행시켜주고 이렇게 돌아가면서 실행시킵니다.  
CPU가 프로세스를 실행시키기 위해서는 프로그램의 코드, 프로세스가 동작을 하면서 메모리상에 정보를 저장해야하기 때문에 프로세스의 stack 메모리 영역, heap 메모리 영역등이 있습니다.  
프로그램의 코드를 실행시켜 스택과 힙영역에 저장합니다. 
프로세스가 실행되고 나면 프로그램과의 연관성은 없다고 봐도 됩니다.  
그래서 프로세스가 실행된 이후에 프로그램을 삭제 시킬 수도 있습니다.


# 프로세스 스케쥴링(process scheduling)

동시에 여러 프로세스가 실행되어야지 노래를 들으면서 인텔리제이도하고 블로그도 쓰고 할 것 입니다.  
이런것들을 결정하는것들이 프로세스 스케쥴링 알고리즘입니다.  
고성능인 애플리케이션은 CPU가 많이 들어가고 계산기 같은건 사용자 입력이 있을때만 사용하면 됩니다.  

이런 CPU를 잘 고르는 기준은 코어클락이 높은것을 고르면 됩니다.  

# 프로세스의 계층 구조

## PID(Process ID)
- 프로세스의 아이디이다.
- 프로세스마다 유니크한 숫자를 가지고 있다.

## 부모 프로세스와 자식 프로세스
- 부모 프로세스는 자식 프로세스를 생성할 수 있다.
- 모든 프로세스는 부모 프로세스를 가지고 있다.

## init 프로세스
- 모든 프로세스의 부모 프로세스이다.
- 리눅스는 커널이 부팅되면 init 프로세스를 생성한다.
- 항상 PID가 1이다.

## 프로세스 종료 처리
- 자식 프로세스가 종료될 때 메모리 영역등 깔끔하게 정리할 수 없기 때문에 부모 프로세스가 이런걸 처리해준다.
- 이러한 이유로 프로세스가 계층구조로 되어있다.

## 고아 프로세스와 좀비 프로세스
- 고아 프로세스는 부모 프로세스가 먼저 종료되어서 부모 프로세스가 자식 프로세스를 정리하지 못하는 프로세스이다.
- init 프로세스가 고아 프로세스를 캐치해서 정리한다.
- 좀비 프로세스는 자식 프로세스가 종료되었는데 부모 프로세스가 정리하지 못해서 남아있는 프로세스이다.

# 프로세스 종료 상태(Exit Status)

## 프로세스 종료 상태
자식 프로세스가 종료될 때 넘겨주는 정보
- 정상 종료 여부
- 시그널을 받아 종료되었는지 여부 및 시그널의 종류
- 코어 덤프를 생성했는지 여부

# 표준 스트림(Standard Stream)
프로세스가 생성되면 기본적으로 세 개의 스트림이 생성된다.  
프로세스는 메모리상 존재하는 실행중인 프로그램이므로 다른 프로세스, 사용자 등 다른 것들과 상호 작용을 해야 한다.
1. 표준 입력 스트림(Standard Input Stream) - #0 stdin
2. 표준 출력 스트림(Standard Output Stream) - #1 stdout
3. 표준 에러 스트림(Standard Error Stream) - #2 stderr

이 세 개의 스트림을 표준 스트림이라고 한다.


# 파일 디스크립터(File Descriptor)
- 파일을 대변하는 객체
- 파일에 대한 작업(읽기/쓰기)을 하기 위해서는 파일 디스크립터를 얻어야함
- 프로세스로 열린 파일 디스크립터 목록을 관리
  
# 포어그라운드 프로세스와 백그라운드 프로세스
- 포어그라운드 프로세스
  - 쉘의 표준 입력이 연결된 프로세스
  - 표준 출력과 표준에러도 쉘과 연결되어 있음
- 백그라운드 프로세스
  - 쉘의 표준 입력이 연결되지 않은 프로세스
  - 표준 출력과 표준 에러는 쉘과 연결되어 있음

# 데몬 프로세스
- MIT 대학의 프로그래머가 만든 용어
- 보이지 않는 곳에서 어떠 닐을 하는 유형에서 영감을 받음
- 백그라운드 프로세스로 동작하기 위해 만들어진 프로세스
- 표준 스트림을 갖고 시작하지만 모두 닫아버림 -> 쉘과의 입출력 교환 불가
- 부모 프로세스를 init프로세스로 변경

# 시그널
비동기 이벤트를 처리하기 위한 프로세스간 통신


# 프로세스 목록 조회 및 구조 파악
```bash
ps
PID   TTY           TIME CMD
86043 ttys000    0:10.96 -zsh
```
- PID : 프로세스 아이디
- TTY : 터미널
- TIME : 프로세스가 실행된 시간
- CMD : 프로세스를 실행한 명령어

ps를 옵션 없이 치면 현재 터미널에서 실행된 프로세스의 목록만 보여주게 된다.

1. ps -f를 치면 프로세스의 구조를 파악할 수 있다.
```bash
ps -f
UID   PID  PPID   C STIME   TTY           TIME CMD
501 86043 86042   0 10:48PM ttys000    0:11.02 -zsh
```
- UID : 프로세스를 실행한 사용자의 아이디이다.
- PPID: 부모 프로세스의 아이디이다.
- C : 프로세스가 사용한 CPU의 사용량이다.
- STIME : 프로세스가 시작된 시간이다.

2. ps -ef를 치면 모든 프로세스의 목록을 볼 수 있다.
- CMD에서 []안에 있는것은 리눅스 커널이 관리하는 프로세스이다.

3. ps -ef --forest를 치면 프로세스의 계층 구조를 볼 수 있다.

# 프로세스 종료 상태
```bash
ls
echo $?
0
```
- $? : ls를 실행한 프로세스의 종료 상태가 0임을 알려준다. 프로세스 종료 상태를 나타내는 변수이다.

# 시그널
프로세스를 죽이는 방법 중 하나이다.

```bash
kill -l # 시그널 목록을 볼 수 있다.
kill -9 86043 # 86043 프로세스를 죽인다.
```

# 포어그라운드 프로세스와 백그라운드 프로세스
```bash
example.sh # example.sh를 실행하면 example.sh가 포어그라운드 프로세스가 된다.
example.sh & # example.sh를 실행하면 example.sh가 백그라운드 프로세스가 된다.
fg # 백그라운드 프로세스를 포어그라운드 프로세스로 바꿔준다.
Control + Z # 포어그라운드 프로세스를 백그라운드 프로세스로 바꿔준다. -> fg로 다시 포어그라운드, bg로 백그라운드
jobs # 백그라운드 프로세스 목록을 볼 수 있다. -l 옵션을 주면 PID까지 볼 수 있다.
fg %1 # 1번 백그라운드 프로세스를 포어그라운드 프로세스로 바꿔준다.
```
