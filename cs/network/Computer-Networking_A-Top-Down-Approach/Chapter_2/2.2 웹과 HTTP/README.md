# 웹과 HTTP
1990년대 까지는 인터넷은 연구자, 학자, 대학생들이 원격 호스트에 로그인하거나,  
로컬에서 원격 혹은 그 반대로 파일을 전송하고 뉴스를 보내고 받고, 메일을 받고 보내는데 주로 이용했다.

### 월드 와이드 웹
1990년대 중반에는 월드 와이드 웹이라는 새로운 인터넷 서비스가 등장했다.  
웹은 여러 데이터 네트워크 중 하나에서 유일한 데이터 네트워크로 격상시켰다.  

### 온디멘드
웹은 온디멘드 서비스를 제공한다.
온디멘드란 사용자가 원하는 즉시 서비스를 제공하는 것을 말한다.
사용자가 주파수를 맞추고 있어야하는 라디오/TV 방송과는 다르다.


## 2.2.1 HTTP 개요
웹의 애플리케이션 계층 프로토콜인 HTTP(HyperText Transfer Protocol)는 웹 서버와 웹 클라이언트 사이에서 이루어지는 요청/응답 프로토콜이다.  

### HTTP의 특징
- 클라이언트/서버
- HTTP 메시지를 교환하여 통신
- 무상태 프로토콜

### 웹페이지
웹페이지는 객체들로 구성됨.
객체는 단순히 단일 URL로 지정할 수 있는 하나의 파일이다.
HTML 텍스트 5개와 jpg 이미지로 구성되어 있으면 이 웹페이지는 6개의 객체로 구성된다.

### 웹 브라우저
- HTTP의 클라이언트를 구현한다.
- 브라우저는 요구한 웹 페이지를 보여주고 여러 가지 인터넷항해와 구성 특성을 제공한다.
- Ngix, Apache, IIS 등의 웹 서버는 웹 페이지를 요청받아 웹 페이지를 반환한다.

<br/>

![스크린샷 2023-11-08 오전 12 35 15](https://github.com/jisu3316/til/assets/95600042/0bdacc1c-a0e1-4f05-9637-4a64edff8c28)  

<br/>
사용자가 웹페이지를 요청할 때 브라우저는 페이지 내부의 객체에 대한 HTTP 요청 메시지를 서버에 보낸다.  
서버는 요청을 수신하고 객체를 포함하는 HTTP 응답 메시지로 응답한다.

### HTTP의 프로토콜
HTTP는 TCP 전송 프로토콜을 사용함.
1. HTTP 클라이언트는 먼저 서버에 TCP 연결을 시작한다.
2. 브라우저와 서버 프로세스는 그들의 소켓 인터페이스를 통해 TCP로 접속한다.
3. 클라이언트는 HTTP 요청 메시지를 소켓 인터페이스로 보내고 서버는 HTTP 응답 메시지를 소켓 인터페이스로 보낸다.

## 2.2.2 비지속 연결과 지속 연결
### 비지속 연결 HTTP
HTTP는 위의 3단계를 거친후 TCP 연결을 닫는다.
즉, 객체 하나에 대해서만 TCP 연결을 맺고 닫는다.
이러한 방식을 비지속 연결이라고 한다.

### 지속 연결 HTTP
비지속 연결의 단점은 각 요청에 대해 TCP 연결을 맺고 끊어야 하므로 많은 비용이 든다는 것이다.
HTTP/1.1 지속 연결에서 서버는 응답을 보낸 후에 TCP 연결을 그대로 유지한다.
같은 클라이언트와 서버 간의 이후 요청과 응답은 같은 연결을 통해 보내진다.
일반적으로 HTTP 서버는 일정 기간（타임아웃 기간） 사용되지 않으면 연결을 닫는다.  

## 2.2.4 HTTP 메시지 포맷
HTTP 명세서는 HTTP 메시지 포맷을 정의한다.

### HTTP 요청 메시지
```java
GET /somedir/page.htm HTTP/1.1
Host: www.someschool.edu
Connection: close
User-agent: Mozilla/5.0
Accept—language: fr
```
첫째, 메시지가 일반 ASCII 텍스트로 쓰여 있어 사람들이 읽을 수 있다.  
둘째, 메시지가 다섯 줄로 되어있고 각 줄은 CR(carriage return)과 LF(line feed)로 구별된다.  
마지막 줄에 이어서 추가 CR과 LF가 따른다

- 첫준은 요청 라인이라고 한다.
- 이후 줄은 헤더 라인이라고 한다.
- 나머지 줄은 본문이다.

요청 라인은 3개의 필드, 메서드 필드, URL 필드, HTTP 버전 필드를 갖는다.  


### HTTP 응답 메시지
```java
HTTP/1.1 200 OK
Connection: close
Date: Tue, 18 Aug 2015 15:44:04 GMT
Server: Apache/2.2.3 （CentOS）
Last-Modified: Tue, 18 Aug 2015 15:11:03 GMT
Content-Length: 6821
Content-Type: text/html
```
1. Connection: close 클라이언트에게 메시지를 보낸 후 TCP 연결을 닫는데 사용한다.
2. Date HTTP 응답이 서버에 의해 생성되고 보낸 날짜와 시간을 나타낸다.
   이 시간이 객체가 생성되거나 마지막으로 수정된 시간을 의미하는 것이 아님을 유의하라.  
   서버가 파일 시스템으로부터 객체를 추출하고 응답 메시지에 그 객체를 삽입하여 응답 메시지를 보낸 시간을 의미한다.
3. Server 메시지가 아파치 웹 서버에 의해 만들어졌음을 나타낸다.  
   HTTP 요청 메시지의 User-agent: 헤더 라인과 비슷하다.
4. Last-Modified 객체가 생성되거나 마지막으로 수정된 시간과 날짜를 나타낸다.   
   이 헤더는 객체를 로컬 클라이언트와 네트워크 캐시 서버（프록시 서버로도 알려짐） 캐싱에 매우 중요하다.
5. Content-Length 송신되는 객체의 바이트 수를 나타낸다.
6. Content-Type 개체 몸체 내부의 객체가 HTML 텍스트인 것을 나타낸다.  
   객체 타입은 파일 확장자로 나타내는 것이 아니라 공식적으로 Content-Type:헤더로 나타낸다.

#### 상태코드
• 200 OK 요청이 성공했고, 정보가응답으로 보내졌다.  
• 301 Moved Permanently 요청 객체가 영원히 이동되었다.  
    새로운 URL은응답 메시지의 Location: 헤더에 나와 있다. 클라이언트 소프트웨어는 자동으로이 새로운 URL을 추출한다.  
• 400 Bad Request 서버가 요청을 이해할수 없다는 일반 오류 코드다.  
• 404 Not Found 요청 문서가 서버에 존재하지 않는다.  
• 505 HTTP Version Not Supported 요청 HTTP 프류투콜 버전을 서버가 지원하지 않는다.  

## 2.2.4 사용자와 서버 간의 상호작용  : 쿠키
HTTP는 무상태 프로토콜이다.  
사용자에 따라 콘텐츠를 제공하기 원하므로 웹사이트가 사용자를 확인하는 방법으로 쿠키를 사용한다.


## 2.2.5 웹 캐싱
웨캐시 (프록시 서버라고도 함)는 기점 웹 서버를 대신하여 HTTP 요구를 충족시키는 네트워크 개체이다.    
웹 캐시는 자체의 저장 디스크를 가지고 있으며, 자주 요청되는 객체의 사본을 저장한다.  

### 웹 캐시 사용 이유
1. 웹 캐시는 원래의 서버보다 빠르게 객체를 제공한다.  
2. 웹 캐시는 트래픽을 대폭으로 줄일 수 있다. -> 트래픽을 줄여 대역폭을 개선할 필요가 없다. 성능개선

### 콘텐츠 전송 네트워크(Content Distribution Network, CDN)
CDN은 웹 캐시의 특수한 종류이다.  
CDN은 전 세계에 여러 개의 웹 캐시를 배치한다.  
공유 CDN(아카마이, 라임 라이트)과 전용 CDN(넷플릭스, 유튜브)이 있다.


### 조건부 GET
조건부 GET은 웹 캐시가 객체가 변경되었는지 확인하는 방법이다.    
헤더의 Modified-Since: 헤더 필드를 사용한다.  
캐시는 요청하는 브라우저에게 객체를 보내주고 자신에게도 객체를 저장한다.  
중요한 것은 캐시가 객체와 더불어 마지막으로 수정된 날짜를 함께 저장한다는 점이다.  

```java
GET /fruit/kiwi.gif HTTP/1.1
Host: www.exotiquecuisine.com
If-modified-since: Wed, 9 Sep 2015 09:23:24
If-modified-since: 헤더 라인의 값이 일주일 전에 서버가보낸 Last-Modified: 헤더 라인의 값과 정확히 일치한다.
```
위와 같이 변경되지 않았으면 웹 서버는 다음과 같이 응답 메시지를 보낸다.

```java
HTTP/1.1 304 Not Modified
Date: 3atz 10 Oct 2015 15:39:29
Server: Apache/1.3.0 (Unix)
```
응답 메시지는 304 Not Modified 상태 라인을 갖고 있으며,  
이는 클라이언트에게 요청 객체의 캐싱된 복사본을 사용하라는 것을 의미한다.

## 2.2.6 HTTP/2
2015년에 표준화 되었다.  

### HTTP/2의 주요 특징
- TCP 연결상에서 멀티 플렉싱 요청/응답 지연 시간을 줄인다.
- 요청 우선순위화
- 서버 푸시
- HTTP 헤더 필드의 효율적인 압축
- 상태 코드, URL, 헤더 필드 HTTP 메소드 자체는 변경 하지 않음
- 클라이언트와 서버 간의 데이터 포맷 방법과 전송 방법을 변경했다.  

HTTP/2의 주요 목표는 병렬 TCP 연결의 수를 줄이거나 제거하는데 있다.  
이는 서버에서 열고 유지 되는데 필요한 소켓의 수를 줄일 뿐만 아니라 목표한 대로 TCP 혼잡 제어를 제어할 수 있게 하는데 있다.  

### HOL(Head of Line) 블로킹
HTML 파일 상단에 비디오 파일이 있다고 치면 이 비디로파일을 처리하는데 시간이 오래 걸린다.  
그 뒤에 객체들은 비디오 파일이 처리될 때까지 기다려야 한다.  
이러한 현상을 HOL 블로킹이라고 한다.  
이것을 해결하기 위해 병렬의 TCP 연결을 사용한다.

### HTTP/2 프레이밍
HOL 블로킹 문제의 해결책으로 등장한 HTTP/2는 각 메시지를 작은 프레임으로 나누고 같은 TCP 연결에서의 요청과 응답 메시지를 인터리빙한다.  
프레이밍은 HTTP/2 프로토콜의 프레임으로 구현된 다른 프레이밍 서브 계층에 의해 이루어진다.  
서버가 HTTP 응답을 보내고자 할 때, 응답은 프레이밍 서브 계층에 의해 처리되며 프레임들로 나눠진다.  
각 프레임은 프레임 헤더와 프레임 페이로드로 구성된다.  
하나의 지속적인 TCP연결상에서 전송되며 클라이언트에 도착하면 프레이밍 서브 계층에서 처음 응답 메시지로 재조립되며 브라우저에 의해 처리된다.  

### 메시지 우선순위화 및 서버 푸싱
요청들의 상대적 우선 순위를 조정하게 함으로써 애플리케이션의 성능을 최적화할 수 있게 해준다.  
클라이언트가 하나의 특정 서버로 동시에 여러 요청을 할 때 1 ~ 256 사이의 가중치를 주어 우선순위를 매길 수 있다.  
높을수록 높은 우선 순위이다.    
이러한 가중치를 이용하여 가장 높은 우선순위의 요청을 위한 프레임을 제일 먼저 보낼 수 있다.  
HTTP/2의 가장 큰 특징은 클라이언트의 요청 없이 추가적인 객체를 클라이언트에게 푸시하여 보낼 수 있다.  

### HTTP/3
QUIC는 UDP 프로토콜 위에 위치하는 애플리케이션 계층에 구현되어 있다.  
QUIC은 메시지 멀티플렉싱(인터리빙), 스트림별 흐름 제어, 저지연 연결 확립과 가은 HTTP에 의미 있는 여러 특징을 갖는다.  
HTTP/3은 QUIC 위에서 작동하도록 설계된 새로운 HTTP 프로토콜로서 2020년 현재 인터넷 드래프트로 나왔으나 완전 표준화된 상태는 아니다.  
