# 트랜잭션 ACID
## ACID는 원자성, 일관성, 고립성, 지속성이다.

- ### 원자성(Atomicty)은 트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다. 예를 들어, 자금 이체는 성공할 수도 실패할 수도 있지만 보내는 쪽에서 돈을 뺴 온느 작업만 성공하고 받는 쪽에 돈을 넣는 작업을 실패해서는 안된다. 원자성은 이와 같은 중간 단계까지 실행되고 실패하는 일이 없도록 하는 것이다.
- ### 일관성(Consistency)은 트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태로 유지하는것을 의미한다. 무결성 제약이 모든 계좌는 잔고가 있어야 한다면 이를 위반하는 트랜잭션은 중단된다.
- ### 독립성(Isolation)은 트랜잭션을 수행 시 다른 트랜잭션의 연산 작업이 끼어들지 못하도록 보장하는 것을 의미한다. 이것은 트랜잭션 밖에 있는 어떤 연산도 중간 단계의 데이터를 볼 수 없을을 의미한다. 은행 관리자는 이체 작업을 하는 도중에 쿼리를 실행하더라도 특정 계좌간 이체하는 양 쪽을 볼 수 없다. 공식적으로 고립성은 트랜잭션 실행내역은 연속적이어야 함을 의미한다. 성능관련 이유로 인해 이 특성은 가장 유연성 있는 제약 조건이다. 자세한 내용은 관련 문서를 참조해야한다.
- ### 지속성(Durability)은 성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 시스템 문제, DB 일관성 체크 등을 하더라도 유지되어야 함을 의미한다. 전형적으로 모든 트랜잭션은 로그로 남고 시스템 장애 발생 전 상태로 되돌릴 수 있다.  트랜잭션은 로그에 모든 것이 저장된 후에만 commit 상태로 간주될 수 있다.



<br/><br/>


# 트랜잭션 격리 레벨
## ISOLATION - 트랜잭션은 서로 간섭하지 않고 독립적으로 동작한다.
- READ UNCOMMITTED
- READ COMMITTED
- REPEATABLE READ
- SERIALIZABLE READ

트랜잭션의 격리 레벨은 위의 4개로 나뉘어 집니다. 위의 4개는 다음 3가지의 현상으로 구분이 됩니다.

- Dirty Read
- Non Repeatable Read
- Phantom READ

위의 3가지중에 몇가지를 방지하고 있느냐, 몇가지를 허용하고 있느냐에 따라 격리레벨이 결정 되게 됩니다.  

<br/><br/>

# Dirty Read
```
예제 
홍길동 잔액은 1000원이 있다.
이순신은 잔액이 100원 있다.

Tx 1번 시작
Tx 1-1 : 홍길동이 이순신에게 900원 송금
Tx 1-2 : 이순신 잔액 1000원 됨


Tx 2번 시작
Tx 2-1 : 이순신 잔액 조회 -> 1000원 나옴

Tx 1-3 : 실패 남

위와 같은 상황에서 Tx2번 에서는 이순신의 잔고를 1000원으로 다음 로직을 수행함
그래서 커밋되지 않은 데이터를 읽었다해서 더티리드 불림
```

<br/><br/>

# Non Repeatable Read

```
Tx 1번
Tx 1-1 : 홍길동의 잔액을 조회함 -> 1000원 나옴

Tx 2번
Tx 2-1 : 홍길동의 잔액을 1200원으로 업데이트함 
Tx 2-2 : commit

Tx 1-2 : 홍길동의 잔액을 조회함 -> 1200원 나옴

위와 같이 Tx1번은 아직 커밋되지 않은 하나의 트랜잭션이지만 1-1에서 조회한 값과 1-2에서 조회한 값이 다른 경우를 Non Repeatable Read 라고 불림.
```


<br/><br/>

# Phantom READ

```
Tx 1번
Read(1000원 보다 많은 잔고) => 홍길동

Tx 2번
UPDATE(이순신) => 1200
commit

TX 1번 
Read(1000원 보다 많은 잔고) => 홍길동, 이순신

위와 같이 없던 데이터가 생기는 것을 Phantom READ 라고 불림.
```

|                  | Dirty Read    | Non Repeatable Read  | Phantom READ |
|------------------|------|--------|-------|
|READ UNCOMMITTED  | O    |    O   | O     | 
|READ COMMITTED    |      |    O   | O     | 
|REPEATABLE READ   |      |        | O     | 
|SERIALIZABLE READ |      |        |       | 


READ UNCOMMITTED 는 3가지 현상이 다 발생합니다.  
READ COMMITTED는 커밋된 데이터만 읽기 때문에 Dirty Read는 발생하지 않는다.  
REPEATABLE READ는 커밋된 데이터만 읽고 더해서 트랜잭션 마다 버전, 트랜잭션 아이디를 부여한다. 그리고 그 트랜잭션 아이디보다 나중에 들어온 트랜잭션의 결과는 보지 않는다.  
SERIALIZABLE READ는 모든 현상을 허용하지 않는다.  

위에서 아래로 갈수록 이상현상이 없다. 하지만 동시 처리량이 매우 낮아 집니다.  

<br/><br/>

# 쓰기락 과 읽기락

|                      | 읽기 락(Shared Lock)| 쓰기 락(Exclusive Lock)|
|----------------------|-------------------|----------------------|
|읽기 락(Shared Lock)    | O                 |    대기               |
|쓰기 락(Exclusive Lock  |  대기              |    대기               |

읽기 락은 Shared Lock 인 만큼 한 트랜잭션이 읽기 락을 획득해도 다른 트랜잭션에서 공유하여 읽을 수 있습니다.  
쓰기 락은 Exclusive Lock 으로 베타적으로 다른 트랜잭션에서 읽지도 쓰지도 못하게 됩니다.  

읽기 락은 SELECT ... FOR SHARE 을 통해 획득  
쓰기락은 SELECT ... FROM UPDATE 또는 UPDATE, DELETE 쿼리 을 통해 획득  
매번 잠금이 생기면 성능저하는 피할 수 없다.  
그래서 mysql에서는 일반 SELECT 절에서는 nonblokcing consistent read로 동작한다.  

MySQL에서는 잠금은 row가 아니라 인덱스를 잠근다. -> 인덱스가 없는 조건으로 Locking Read시 불필요한 데이터들이 잠길 수 있음.  
