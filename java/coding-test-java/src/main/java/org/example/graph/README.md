# 그래프의 개념
그래프는 노드(vertex)와 간선(edge)을 이용한 비선형 데이터 구조이다.  
보통 그래프는 데이터 간의 관계를 표현하는데 사용한다.
데이터를 노드로, 노드 간의 관계나 흐름을 간선으로 표현한다.
간선은 방향이 있을 수도 있고 없을 수도 있다.
만약 관계나 흐름에서 정도를 표현할 필요가 있다면 가중치라는 개념을 추가하여 표현한다.

# 그래프의 특징과 종류

## 흐름을 표현하는 방향성
그래프는 방향성, 가중치, 순환 특성에 따라 종류를 구분할 수 있다.  
방향이 있는 간선을 포함하면 방향 그래프(directed graph)라고 하고, 방향이 없는 간선을 포함하면 무방향 그래프(undirected graph)라고 한다.

이때 방향 그래프는 어느 한쪽으로만 간선이 있는것이 아니라 서로 반대를 가리키는 간선이 있을 수도 있다.

## 흐름의 정도를 표현하는 가중치
어떤 데이터는 흐름의 방향뿐 아니라 양도 중요할 수 있다.
그런 정도를 간선에 표현할 때 이를 가중치라고한다.
가중치가 있는 그래프를 가중치 그래프(weighted graph)라고 한다.

## 시작과 끝의 연결 여부를 보는 순환
순환은 특정 노드에서 시작해 간선을 따라 다시 돌아오는 경로가 있는 것을 말한다.
순환이 존재하는 그래프를 순환 그래프(cyclic graph)라고 하고 순환이 존재하지 않는 그래프를 비순환 그래프(acyclic graph)라고 한다.

# 그래프 구현
예를 들어 서울에서 부산으로 유동 인구가 8000명 발생했다는 내용을 그래프로 표현한다.  
- 데이터를 담고 있는 노드(서울, 부산)
- 노드를 잇는 간선(서울과 부산의 연결 유무)
- 간선의 방향(서울에서 부산 방향으로)
- 간선의 가중치(유동 인구 8000명)


## 인접 행렬 그래프
배열의 인덱스는 노드, 배열의 값은 노드의 가중치  
인덱스의 세로 방향을 출발 노드, 가로 방향을 도착노드로 생각하면 자연스럽게 그래프를 표현할 수 있다.

## 인접 리스트 그래프
인접 리스트로 그래프를 표현하려면 노드를 정의해야 한다.
값(v)과 가중치(w)를 묶어 관리한다.  
인접 리스트 그래프 표현 방식은 다음과 같은 과정으로 동작한다.  
1. 우선은 노드 개수만큼 배열을 준비한다.
2. 배열의 인덱스는 각 시작 노드를 의미하며 배열의 값에는 ArrayList를 연결한다.

만약 1노드에서 2노드로 갈때 가중치가3이라하면
```java
List<Integer>[] graph = new ArrayList[1];
for (int i = 0; i < 1; i++) {
    graph[i] = new ArrayList<>();
}

graph[0].add(2);
graph[0].add(3);

System.out.println("graph = " + graph[0]);
graph = [2, 3]
```
이런식으로 구성할 수 있다.

## 인접 행렬과 인접 리스트의 장단점
### 인접 행렬의 장단점
인접행렬은 크게 두 가지 단점이 있다.  
첫 번째 단점은 인접 행렬로 희소 그래프를 표현하는 경우이다.
희소 그래프는 노드 수에 비해 간선 수가 매우 적은 그래프를 말한다.
인접 행렬은 크기가 고정되어 있으므로 최악의 경우를 고려해서 크기를 결정해야 한다. 
따라서 노드가 N개 있을 때 모든 간선이 연결되는 최악의 경우를 고려해서 N * N 크기의 인접 행렬 공간 중 대부분의 공간은 실제로 사용하지 않아 비효율적이다.  
두 번째 단점은 노드들의 값의 차이가 매우 큰 그래프를 표현하는 경우이다.  
예를 들어 노드 값이 순차적으로 증가하지 않고 1, 2, 3, 999와 같이 간격이 크면 가장 큰 노드의 값인 999를 기준으로 인접 행렬의 크기를 잡아야한다.  
인접 행렬의 장점은 간선의 정보를 확인할 때 시간 복잡도가 O(1)이라는 점이다.  
인접 행렬에서는 인덱스 임의 접근으로 노드 간 간선 정보를 바로 확인할 수 있기 때문이다. 예를 들어 2에서 93이 연결되어 있는지 탐색하려면 array[2][93]에 가중치가 있는지만 확인하면 된다.


### 인접 리스트의 장단점
인접 리스트는 정점 A에 연결된 간선의 정보를 빠르게 알 수 있다는 장점이 있다.  
인접 행렬로 구현했다면 정점 A에 연결한 간선 정보를 알기 위해 [A, 0], [A, 1] ... [A, N]와 같이 모든 간선을 탐색해야 하므로 시간 복잡도는 O(N)이다.  
하지만 인접 리스트에서는 ArrayList[A]만 확인하면 되므로 연결된 간선만 빠르게 체크할 수 있다.

## 깊이 우선 탐색과 너비 우선 탐색
- 깊이 우선 탐색은 깊게 탐색 후 되돌아오는 특성이 있다.
- 너비 우선 탐색은 가중치가 없는 그래프에서 최단 경로를 보장한다.

### 깊이 탐색 후 되돌아오는 깊이 우선 탐색
모든 가능한 해를 찾는 백트래킹 알고리즘을 구현할 때나 그래프의 사이클을 감지해야 하는 경우 활용한다.  
코딩 테스트에서 탐색을 해야 할 때, 최단 경로를 찾는 문제가 아니면 깊이 우선 탐색을 우선 고려해보는 것이 좋다.
백트래킹은 탐색하고 있는 방향의 역방향으로 되돌아가는 동작이다.

### 최단 경로를 보장하는 너비 우선 탐색
시작 노드로부터 직접 간선으로 연결된 모든 노드를 먼저 방문하기 때문에 최단 경로를 보장한다.  
미로찾기 문제에서 최단 경로를 찾거나, 네트워크 분석 문제를 풀 때 활용할 수 있다.

