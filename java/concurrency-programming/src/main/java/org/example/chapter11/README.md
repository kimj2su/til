# BlockingQueue
- 기본적으로 스레드 풀은 작업이 제출되면 corePoolSize의 새 스레드를 추가해서 작업을 할당하고 큐에 작업을 바로 추가히지 않는다.
- corePoolSize를 초과해서 스레드가 실행 중이면 새 스레드를 추가해서 작업을 할당하는 대신 큐에 작업을 추가한다.(큐가 가득찰 때까지)
- 큐에 공간이 가득차게 되고 스레드가 maxPoolSize 이상 실행 중이면 더 이상 작업은 추가되지 않고 거부 된다.

## SynchronousQueue
- newCachedThreadPool() 에서 사용한다.
- 크기가 0인 큐로서 작업을 대기열에 넣으려고 할 때 실행할 스레드가 없으면 즉시 새로운 스레드가 생성된다.

## LinkedBlockingQueue
- Executors.newFixedThreadPool() 에서 사용한다.
- 무제한 크기의 큐로서 corePoolSize의 스레드가 모두 사용 중인 경우 새로운 작업이 제출 되면 대기열에 등록하고 대기하게 된다.
- 무제한 크기의 큐이기 때문에 corePoolSize의 스레드만 생성하고 maxPoolSize는 무시된다. -> 큐가 다 차야 maximumPoolSize의 스레드가 생성되기 때문에.

## ArrayBlockingQueue
- 내부적으로 고정된 크기의 배열을 사용하여 작업을 추가하고 큐를 생성할때 최대 크기를 지정해야하며 한 번 지정된 큐의 크기는 변경할 수 없다.
- 큰 대기열과 작은풀(큐의 크기가 크지만 스레드의 개수가 작은)을 사용하면 CPU 사용량 및 OS 리소스 및 컨텍스트 전환 오버헤드가 최소화 되지만 낮은 처리량을 유발할 수 있다.
- 작은 대기열과 큰 풀(큐의 크기가 작지만 스레드의 개수가 큰)을 사용하면 CPU 사용량이 높아지지만 대기열이 가득 찰 경우 추가적인 작업을 거부하기 때문에 처리량이 감소할 수 있다.
- 그렇기 때문에 ArrayBlockingQueue을 사용할 때는 정책을 잘 정해야 한다.

|메서드| 반환값                                    | 블록 여부| 예외처리                   |
|---|----------------------------------------|---|------------------------|
|add(e)| 성공시 true, 실패시 예외                       |X| IllegalStateException  |
|offer(e)| 성공시 true, 실패시 false                    |X| InterruptedException   |
|put(e)| X                                      |O| X                      |
|remove(e)| 큐에서 요소를 제거하고 반환, <br/> 큐가 비어 있으면 예외 발생 |X| NoSuchElementException |
|poll(e)| 큐에서 요소를 제거하고 반환, <br/> 큐가 비어 있으면 null 반환 |X| X                      |
|take(e)| 큐에서 요소를 제거하고 반환, <br/> 큐가 비어 있으면 대기 |O| InterruptedException   |

- add(E e) : 사용하기 쉽고 간단하다.
- remove(): 큐가 가득 차 있거나 비어 있을때 요소 추가/삭제 시 예외를 발생시키므로 예외처리가 필요하다.

- offer(E e): 큐가 가득 차 있거나 비어 있을때 요소 추가/삭제시 예외를 발생시키지 않는다.
- put(E e): 요소를 추가하고 제거할 때 실패할 경우 false 또는 null을 반환하므로 예외 처리는 필요 없지만 결과에 대한 로직이 필요하다.

- poll() : 큐가 가득 차 있거나 비어있을 때 요소 추가/삭제시 메서드에서 블록된다.
- take() : put() take() 메서드는 블록되어 대기하기 때문에 작업을 동기적으로 조절하는데 유용하다. 무기한 대기가 될 수 있기 때문에 타임 아웃을 지원하는 다른 메서드를 활용해야 할 수 있다.