# 계층형 아키텍처의 문제는 무엇일까?
계층형 아키텍처는 웹 - 도메인 - 영속성으로 구성된 전통적인 웹 애플리케이션 구조이다.  
사실 계층형 아키텍처는 견고한 아키텍처 패턴이다.  
계층을 잘 이해하고 구성하면 독립적인 도메인 로직을 작성할 수 있고, 도메인 로직에 영향을 주지 않고 웹 계층과 영속성 계층에 사용된 기술을 변경할 수 있다.  


## 계층형 아키텍처는 데이터베이스 주도 설계를 유도한다.
정의에 따르면 전통적인 계층형 아키텍처의 토대는 데이터 베이스이다.  
엡 계층은 도메인 계층에 의존하고 도메인 계층은 영속성 계층에 의존하기 때문에 자연스레 데이터베이스에 의존하게 된다.  

그동안 만들어 본 애플리케이션의 유스케이스를 떠올려보면 도메인 로직보단 영속성 계층을 먼저 구현하였다.  
이는 계층형 아키텍처답게 의존하는 방향대로 자연스럽게 구현한것이다.  
데이터베이스 중심적인 아키텍처가 만들어지는 가장 큰 원인은 ORM(Object-Relational Mapping)이다.  

도메인(서비스) -> 영속성(엔티티, 레포지토리)  
ORM에 관리 되는 엔티티들은 일반적으로 영속성 계층에 둔다.  
그렇기 때문에 도멤인 계층은 엔티티에 접근할 수 있으므로 사용되기 마련이다.  
하지만 이렇게 되면 영속성 계층과 도메인 계층에 강한 결합이 생긴다.  
서비스는 영속성 모델을 비즈니스 모델 처럼 사용하게 되고 영속성 코드가 사실상 도메인 코드로 녹아들어가 둘 중 하나만 바꾸는 것이 어렵게 된다.  
이는 유연하고 선택의 폭을 넓혀준다던 계층형 아키텍처의 목표와 정확히 반대되는 상황이다.

## 지름길을 택하기 쉬워진다.
계층형 아키텍처 자체는 위 규칙 외의 다른 규칙을 강제하지 않는다.  
따라서 영속성 계층(제일 하단)에서 상위 계층에 있는 컴포넌트에 접근해야 한다면 컴포넌트를 아래로 내려버리면 된다.  
이러한 방법이 반복되어 어느 계층에도 속하지 않는 것 처럼 보이는 헬퍼 컴포넌트나 유틸 컴포넌트들이 아래 계층으로 내려올 가능성이 크다.  
그러니 아키텍처의 '지름길 모드'를 끄고 싶다면 적어도 추가적인 아키텍처 규칙을 강제하지 않는 한 계층은 최선의 선택은 아니다.  
여기서 강제란 시니어 개발자의 코드 리뷰가 아닌 컴파일러나 빌드 시스템이 강제하는 것을 의미한다.


## 테스트 하기 어려워 진다.
계층형 아키텍처를 사용할 때 일반적으로 나타나는 변화의 형태는 계층을 건너 뛰는 것이다.  
엔티티의 필드를 단 하나만 조작하면 되는 경우에 웹 계층에서 바로 영속성 계층이 접근하면 도메인 계층을 건드릴 필요가 없지 않을까?  
이러한 생각이 들게 된다. -> 두가지 문제가 생긴다.  
첫번째 문제는 단 하나의 필드를 조작하는 것에 불과해도 도메인 로직을 웹 계층에 구현하게 된다는 것이다.  
유스케이스가 확장될때 많은 도메인 로직들이 엡 계층에 추가해서 애플리케이션 전반에 걸쳐 책임이 섞이고 핵심 도메인 로직들이 퍼지기 마련이다.  
두번째는 웹 계층 테스트에서 도메인, 영속성 계층도 모킹해야 한다.  
이는 테스트를 작성하기 어렵게 만들고 테스트를 작성하지 않는 방향으로 가는 첫걸을이다. 왜냐하면 복잡한 설정을 할 시간이 없다.  
어느 순간에는 테스트 코드를 작성하는 것보다 종속성을 이해하고 목을 만드는데 더 많은 시간이 걸리게 된다.


## 유스케이스를 숨긴다.
개발자들은 새로운 유스케이스를 구현하는 새로운 코드를 짜는 것을 선호한다.  
그러나 기존 코드를 바꾸는데 더 많은 시간을 쓴다.  
기능을 추가하거나 변경할 적절한 위치를 찾는 일이 빈번하기 때문에 아키텍처는 코드를 빠르게 탐색하는데 도움이 되어야 한다.  
계층형 아키텍처는 이러한 탐색을 어렵게 만든다. -> 유스케이스가 간단하다면 웹 계층, 도메인 계층, 영속성 계층, 특정 컴포넌트 어디에도 있을 수 있다.  

또한 계층형 아키텍처는 너비에 관한 규칙을 강제하지 않는다.  
하나의 서비스에서 여러개의 레포지토리, 헬퍼, 유틸리티에 접근하는것을 강제하지 않고 이는 영속성 계층에 많은 의존성을 갖게 된다.  
이러한 의존성을 테스트하기 어렵게 만들고 유스케이스를 책임지는 서비스를 찾기도 어려워진다.  
고도로 특화된 좁은 도메인 서비스가 유스케이스 하나씩만 담당하게 한다면 이런 작업들이 얼마나 수월해질까?  
UserService 대신 RegisterUserService를 바로 열어서 작업을 시작하는것처럼..

## 동시 작업이 어려워진다.
```mongodb-json
지연되는 소프트웨어 프로젝트에 인력을 더하는 것은 개발을 늦출 뿐이다. - 맨머스 미신: 소프트웨어 공학에 관한 에세이
```
계층형 아키텍처는 동시 작업을 어렵게 만든다.  
애플리케이션에 새로운 유스케이스를 추가한다고 상상해보자. 개발자는 3명이 있다.  
영속성, 도메인, 웹 계층을 따로 개발하고 싶지만 계층형은 영속성 계층이 먼저 개발 되어야하고 도메인, 웹 계층을 만들어야 한다.  
또한 코드에 넓은 서비스가 있다면 서로 다른 기능을 동시에 작업하기가 더욱 어렵다.  
서로 다른 유스케이스에 대한 작업을 동시에 하게 되면 병합 충돌(merge conflict)과 잠재적으로 이전 코드로 되돌려야 하는 ㅁㄴ제를 야기한다.

## 유지보수 가능한 소프트웨어를 만드는데 어떻게 도움이 될까?
올바르게 구축하고 몇 가지 추가적인 규칙들을 적용하면 계층형 아키텍처는 유지보수 하기 매우 쉬워지며 코드를 쉽게 변경하거나 추가할 수 있게 된다.  
그러나 계층형 아키텍처는 많은 것들이 잘못된 방향으로 흘러가도록 용인한다.  
아주 엄격한 자기 훈련 없이는 시간이 지날 수록 품질이 저하되고 유지보수하기가 어려워지기 쉽다.  
어떤 아키텍처를 선택하든지 계층형 아키텍처의 함정을 염두에 두면 지름길을 택하지 않고 유지보수하기에 더 쉬운 솔루션을 만드는데 도움이 될 것이다.
