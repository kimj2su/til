# 의존성 역전하기

## 단인 책임 원칙
```
하나의 컴포넌트는 오로지 한 가지 일만 해야 하고, 그것을 올바르게 수행해야 한다.
```  
이는 좋은 조언 이지만 단일책임 원칙의 실제 의도는 아니다.
```
컴포넌트를 변경하는 이유는 오직 하나뿐이어야 한다.
```
이것이 단일 책임 원칙의 실제 의도이다. 책임은 사실 오로지 한 가지 일만 하는것 보다는 변경할 이유로 해석해야 한다.  

만약 컴포넌트를 변경할 이유가 오로지 한 가지라면 컴포넌트는 딱 한 가지 일만 하게 된다. 
하지만 이보다 더 중요한 것은 변경할 이유가 오직 한 가지라는 그 자체이다.  
아키텍처에서는 어떤 의미 일까?  

만약 컴포넌트를 변경할 이유가 한 가지라면 우리가 어떤 다른 이유로 소프트웨어를 변경하더라도 이 컴포넌트에 대해서는 전혀 신경 쓸 필요가 없다.  
소프트웨어가 변경되더라도 여전히 우리가 기대한 대로 동작할 것이기 때문이다.  

## 의존성 역전 원칙
영속성 계층의 코드가 변경 된다고 해서 도메인 계층의 코드를 변경하기는 싫다. 어떻게 해야 할까?  
의존성 역전 원칙(Dependency Inversion Principle)은 이러한 문제를 해결하기 위한 원칙이다.  
```mongodb-json
코드상의 어떤 의존성이든 그 방향을 바꿀 수(역전시킬 수) 있다.
```
사실 의존성의 양쪽 코드를 모두 제어할 수 있을 때만 의존성을 역전 시킬 수 있다.  
만약 외부 라이브러리를 사용한다면 제어할 수 없기 때문에 의존성을 역전할 수 없다.  

엔티티는 도메인 객체를 표현하고 도메인 코드는 이 엔티티들의 상태를 변경하는 일을 중심으로 하기 때문에 먼저 엔티티를 도메인 계층으로 올린다.  
이렇게 되면 영속성 계층의 레포지토리가 도메인 계층의 엔티티를 의존하기 때문에 순환 참조가 일어 난다.  
이 부분이 바로 DIP를 적용하는 부분이다.  
도메인 계층에 레포지토리에 대한 인터페이스를 만들고 실제 레포지토리는 영속성 계층에서 구현하게 하는것이다.
![image](https://github.com/kimj2su/til/assets/95600042/b33704c0-2c57-43c9-bea7-a18bf25b1d68)
위와 같은 그림으로 영속성 코드에 있는 숨막히는 의존성으로부터 도메인 로직을 해방 시켰다.

## 클린 아키텍처 
로버트 C. 마틴은 클린 아키텍처라는 용어를 같은 이름의 책에서 정립했다.  
클린 아키텍처는 설계가 비즈니스 규칙의 테스트를 용이하게 하고 비즈니스 규칙은 프레임워크, 데이터베이스, UI기술, 그 밖의 외부 애플리케이션이나 인터페이스로부터 독립적일 수 있다고 이야기 했다.  

이는 도메인 코드가 바깥으로 향하는 어떤 의존성도 없어야 함을 의미한다.  
대신 의존성 역전의 도움으로 모든 의존성이 도메인 코드를 향하고 있다.

![clean_architecture](https://github.com/kimj2su/til/assets/95600042/4950e52a-2107-4251-a8b1-351d922b9cd6)

이 아키텍처에서 계층들은 동심원으로 둘러 싸여 있다.  
이 아키텍처의 가장 주요한 규칙은 의존성 규칙으로 계층간의 모든 의존성이 안쪽으로 향해야 한다는 것이다.  

여기서 유스케이스는 계층 구조에서 서비스라고 불렀던 것들인데 단일 책임을 갖기 위해 조금 더 세분화돼 있다.  
이를 통해 넓은 서비스 문제를 피할 수 있다.  
도메인 코드에서는 어떤 영속성 프레임 워크나 UI 프레임 워크가 사용되는지 알 수 없기 때문에 특정 프레임워크에 특화된 코드를 가질 수 없고
비즈니스 규칙에 집중할 수 있다. 그래서 도메인 코드를 자유롭게 모델링할 수 있다.  
예를 들어 도메인 주도 설계 (Domain-Driven Design)을 사용하거나 특정 프레임워크에 종속되지 않는 코드를 작성할 수 있다.  

도메인 계층이 영속성이나 UI 같은 외부 계층과 철처하게 분리돼야 하므로 애플리케이션의 엔티티에 대한 모델을 각 계층에서 유지보수해야 한다.

## 육각형 아키텍처(헥사고날 아키텍처)
알리스테어 콕번이 만든 용어로 꽤 오랫동안 사용돼 왔다.
![port-adapter-image](https://github.com/kimj2su/til/assets/95600042/c6dc9bc8-fd9e-42d5-9c36-78b212afab3c)
애플리케이션 코어가 융각형으로 표현되어 이 아키텍처의 이름이 되었다.  
다른 시스템이아 어댑터와 연결되는 4개 이상의 면을 가질 수 있음을 보여주기 위해 일반적인 사각형 대신 융각형을 사용했다고 한다.  

육각형 안에는 도메인 엔티티와 이와 상호작용하는 유스케이스가 있다.  
육각형에서 외부로 향하는 의존성이 없어서 클린 아키텍처에서 제시한 의존성 규칙이 그대로 적용된다.  

육각형 바깥에는 애플리케이션과 상호 작용하는 다양한 어댑터들이 있다.  
웹 브라우저와 상호작용하는 웹 어댑터도 있고, 일부 어댑터는 외부 시스템과 상호 작용하며, 데이터 베이스와 상호작용하는 어댑터도 있다.  

애플리케이션 코어와 어댑터들 간의 통신이 가능하려면 애플리케이션 코어가 각각의 포트를 제공해야 한다.  
주도하는 어댑터(driving adapter)에게는 그러한 포트가 코어에 있는 유스케이스 클래스 중 하나에 의해 구현되고
어댑터에 의해 호출되는 인터페이스가 될 것이고, 주도되는 어댑터에게는 그러한 포트가 어댑터에 의해 구현되고 코어에 의해 호출되는 인터페이스가 될 것이다.  

이러한 핵심 개념으로 인해 포트와 어댑터 아키텍처로도 알려져 있다. 

## 유지보수 가능한 소프트웨어를 만드는 데 어떻게 도움이 될까?
클린 아키텍처는 의존성을 역전시켜 도메인 코드가 다른 바깥쪽 코드에 의존하지 않게 함으로써 영속성과 UI에 특화된 모든 문제로부터 도메인 로직의 결함을 제거하고 코드를 변경할 이유의 수를 줄일 수 있다.  
그리고 변경할 이유가 적을수록 유지보수성은 더 좋아진다.  

또한 도메인 코드는 비즈니스 문제에 딱 맞도록 자유롭게 모델링 될 수 있고, 영속성 코드와 UI 코드도 영속성 문제와 UI 문제에 맞게 자유롭게 모델링 될 수 있다.  
