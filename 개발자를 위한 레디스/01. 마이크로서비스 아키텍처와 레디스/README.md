# NoSQL의 등장 배경
소프트웨어의 핵심은 데이터다.   
올바른 데이터 저장소를 선택하고 운영하는 문제는 굉장히 중요하며, 이는 곧 애플리케이션의 성능과 확장성, 가용성과 신뢰성 등 여러 문제와 직접적인 연관을 갖는다.  

## 모놑리식 아키텍처
전통적인 소프트웨어 개발 모델로, 전체 애플리케이션을 하나의 통합된 패키지로 개발, 배포하는 방법이다.  
작은 규모의 프로젝트나 애플리케이션은 이 방식으로 운영하기 쉬울 수 있다.  
하지만 규모가 커지면 한개의 시스템에 문제가 생기면 이는 곧 전체 시스템의 장애로 이어진다.  

## 마이크로서비스 아키텍처
마이크로서비스는 독립된 각각의 모듈을 조립해 하나의 서비스를 만드는 아키텍처이다.  
기능별로 작게 나뉘어진 서비스가 독립적으로 동작하는 서비스를 의미한다.  

## 데이터 저장소 요구 사항의 변화
최근의 서비스에서는 정해진 형태가 없고, 크기와 구조를 예측할 수 없는 비정형 데이터가 증가하고 있다.  
이러한 비정형 데이터는 다차원적이거나 깊은 계층 구조를 가질 수 있어 관계형 데이터베이스의 정형화된 테이블에서는 관리하기가 어렵다.  
NoSQL을 사용할 경우 개발 팀이 데이터 구조를 바꿀 수 있어 빠른 개발이 가능하다는 장점이 있다.  

## NoSQL의 특징
NoSQL이란 용어는 'Not Only SQL'의 약자로, 관계형 데이터베이스가 아닌 다른 형태의 데이터베이스를 의미한다.  

### 실시간 응답
인간의 응답에 대한 연구에 따르면 사람은 100ms가 넘어가면 지연이 있다고 인지한다고 한다.  
데이터베이스에서 데이터를 가져올 때 발생하는 지연율은 0~1ms 이내여야 한다.

### 확장성
서비스의 업그레이드로 인한 계획적인 확장뿐만 아니라 새해 첫날의 트래픽, 세일기간의 이벤트 등 예상치 못한 이벤트로 인한 
트랜잭션의 증가에 유연하가 확잘될 수 있다.

### 고가용성
데이터 저장소는 장애 상황에서 신속하게 복구돼 항상 사용할 수 있는 상태를 유지해야 한다.

### 클라우드 네이티브
클라우드 제공 업체에서 제공하는 DBaas(Database as a Service)를 사용할 수 있다.  

### 단순성
마이크로서비스 아키텍처가 세분화 될 수록 관리 포인트가 늘어난다.  
개발자는 쉽게 데이터를 사용하고 싶어한다.  
한편으로는 한 가지의 데이터 모델이 모든 서비스에 최적화되진 않기 때문에 서비스별로 적절한 데이터 모델 즉, 멀티 모델 데이터베이스를 사용하길 원한다.

### 유연성
디지털 산업의 발전과 함께 다양한 데이터 유형이 폭발적으로 증가했다.  
NoSQL은 관계형 데이터베이스보다 다양한 방식으로 비정형 데이터를 저장할 수 있는 방법을 제공한다.

## NoSQL 데이터 저장소 유형

### 그래프 유형
그래프 유형의 데이터베이스는 엔티티 간의 관계를 효율적으로 저장하도록 설계했다.  
노드, 에지, 속성으로 데이터를 나타내고, 데이터의 엔티티는 노드로 표현하며 데이터 사이의 관계를 에지로 나타낸다.  
그래프 유형의 데이터 베이스는 관계를 저장하고 표현할 때 유용하게 사용될 수 있으며, 저장되는 속성의 크기가 크거나 혹은 매우 많은 속성을 저장할 때에는 적합하지 않은 경우가 많다.  

- 추천 서비스에서 유용하게 사용될 수 있다.  
  - SNS에서 유저(노드)간 친구 관계(에지)를 이용해 새로운 친구를 추천해주는 서비스를 구현할 수 있다.
- 쇼핑몰
  - 관심 분야나 구매 이력이 비슷한 다른 유저가 구입한 제품을 파악해 관심이 있어 할 만한 상품을 추천해줄 수 있는 기능 또한 쉽게 구현할 수 있다.

### 칼럼 유형
칼럼 유형의 NoSQL은 테이블을 행이 아닌 열을 기준으로 저장한다는 철학으로 설계했다.  
대용량의 데이터에 대한 집계 쿼리를 다른 유형보다 훨씬 빠르게 처리할 수 있어 기업의 BI 분석을 위한 데이터베이스에서 사용한다.  
Apache Cassandra, HBase, Scylla 등이 대표적인 칼럼 유형의 데이터베이스이다.  

### 문서 유형
문서 유형의 데이터베이스는 JSON 형태로 저장돼, 개발자들이 편하게 사용할 수 있다.  
이 유형에서는 모든 값은 항상 키와 연결되는 계층의 트리와 같은 구조를 갖는다.
MongoDB, Couchbase, Elasticsearch 등이 대표적인 문서 유형의 데이터베이스이다.

### 키-값 유형
키-값 유형은 가장 단순하고 빠르다.  
키-값 유형에서 키는 관계형 데이터베이스의 PK라고 생각할 수 있다.  
모든 값은 키에 연결되어 있으며, 키 자체도 유의미한 데이터이다.  
키를 사용해 값을 검색하고 키를 삭제하면 값도 삭제된다.  
데이터의 저장이 쉬워 수평적 확장이 쉽다.  
게임이나 IOT 같은 실시간 서비스에서는 사용자의 경험을 위해 빠른 응답 속도가 중요하다.  
로그를 남기거나 대규모 세션을 실시간으로 관리 해야 하는 상황에서는 지연시간을 최소화 해야한다.  
키-값 유형의 데이터 모델은 그 구조의 단순성으로 인해 빠른 데이터 액세스와 처리속도를 보장해준다.  
레디스, AWS elasticache, DynamoDB, Memcached 등이 있다.

# 래디스란?
Remote Dictionary Server의 약자로 고성능 키-값 유형의 인메모리 NoSQL 데이터베이스로 오픈 소스 기반의 데이터 저장소이다.  

## 레디스의 특징

### 1. 실시간응답(빠른 성능)  

기존의 데이터베이스는 디스크에 데이터를 저장하고 읽어오는데 시간이 걸린다.  
인메모리 데이터베이스에서는 모든 데이터가 메모리에 저장하여 관리 된다.

### 2. 단순성
레디스는 키-값 형태로 데이터를 관리할 수 있는 데이터 저장소이다.  
문자열, hash, set 등 다양한 데이터 구조를 지원하며 애플리케이션에서 가공 없이 쉽게 사용할 수 있다.  
임피던스 불일치란 관계형 데이터베이스와 애플리케이션 언어와의 구조, 기능의 차리오 발생하는 충돌을 의미하는데
 레디스는 내장된 다양한 자료구조를 통해 임피더스 불일치를 해소한다.  

레디스를 사용할때 주의할 점은 싱글 스레드로 동작한ㄷ.  
정확히 말하면 메인 스레드 1개와 별도의 스레드 3개 총 4개의 스레드로 동작한다.  
클라이언트의 커맨드를 처리하는 부분은 이벤트 루프를 활용한 싱글 스레드로 동작한다.  
최소 하나의 코어만 있으면 레디스를 사용할 수 있어 배포가 쉽고, CPU가 적은 서버에서도 좋은 성능을 낼 수 있다.  

### 3. 고가용성
레디스는 자체적으로 HA(High Availability) 기능을 제공한다.  
복제를 통해 데이터를 여러 서버에 분산 시킬 수 있으며, 센티넬은 장애 상황을 탐지해 자동으로 페일오버를 시켜준다.  
애플리케이션이 센티넬을 이용해 레디스에 연결하는 구조에서는 마스터에 장애가 발생하더라도 레디스로의 엔드포인트를 변경할 필요 없이 페일오버가 완료돼 
정상화된 마스터 노드를 사용할 수 있다.

### 4. 확장성
레디스에서 클러스터 모드를 사용한다면 손쉬운 수평적 확장이 가능하다.  
데이터는 레디스 클러스터 내에서 자동으로 샤딩된 후 저장되며, 여러개의 복제본이 생성될 수 있다.  
이 데이터의 분리는 데이터베이스 레이어에서 처리되며 애플리케이션에서는 대상 데이터가 어떤 샤드에 있는지 신경 쓰지 않아도 되므로
레디스를 사용할 때와 동일하게 데이터를 가져오고 저장할 수 있다.  
클러스터 구조에서 모든 레디스 인스턴스는 클러스터 버스라는 프로토콜을 이용해 서로 감시하고 있으며, 이를 이용해 클러스터 마스터 노드에 문제가 발생하면
자동으로 페일오버를 시켜 고가용성을 유지할 수 있다.

### 5. 클라우드 네이티브 - 멀티 클라우드
클라우드 네이티브는 클라우드 환경에 특화된 애플리케이션의 개발 및 운영 방식을 의미한다.  
이 방식은 마이크로서비스, 컨테이너, 오케스트레이션 그리고 데브옵스와 같은 현대의 개발 및 운영 패러다임을 포용하며, 빠른 배포와 확장서으 높은 복원력을 중심으로 
한 애플리케이션을 추구한다.  

멀티 클라우드는 여러 클라우드 제공업체의 서비스를 동시에 혹은 혼합해 활용하는 전략을 의미한다.  
이 전략은 단일 클라우드 환경의 장애나 제한된 자원에 대한 의존성을 줄이며, 각 클라우드  서비스 제공자의 강점을 활용할 수 있게 해준다.  
또한 멀티 클라우드 방식은 사용자에 따라 더 가까운 곳에 저장소를 위치해 대기시간을 줄이고 장애 상황에 더욱 강건하게 대처할 수 있다.  

- AWS : ElastiCache
- Azure : Azure Cache for Redis
- GCP : Memorystore for Redis
- NHN Cloud : Easy Cache
- NAVER Cloud : Cloud DB for Redis


# 마이크로서비스 아키텍처와 레디스
레디스는 마이크로서비스 아키텍처에서 데이터 저장소 그 이상으로 활용될 수 있는 유연한 데이터베이스다.  

## 데이터 저장소로서의 레디스
레디스는 마이크로서비스 아키텍처에서 각 서비스별 개별 저장소로 사용하기에 알 맞다.  
설치가 간편하고, 최소한의 리소스로 막대한 처리량을 낼 수 있으며, 다양한 자료 구조르 제공하면서도 사용이 간단하기 때문에 마이크로 서비스의 요구 사항에 맞는 데이터를 저장하기 편한다.  
고가용성을 위해 로드밸런서나 프록시등 추가적인 서비스 없이도 하나의 튼튼한 저장소로서의 역할을 수행하기에 충분하다.  

메모리에 있는 데이터가 영구 저장되지 않기 때문에 데이터 저장소로 사용하기 위해 레디스의 도입을 고민할 때 데이터의 영속성을 고민할 수 있으나,  
레디스의 데이터는 AOF(Append Only File)와 RDB(Redis DataBase) 방식을 통해 디스크에 주기적으로 영구 저장이 가능하다.  

## 메시지 브로커로서의 레디스
마이크로서비스 아키텍처에서 각 서비스는 완전히 분리돼 있는 구조로 동작하기 때문에 서로 다른 서비스 간에 지속적인 통신이 필요하다.  
메시징 큐 혹은 stream과 같은 메시지 브로커르 이용해 서비스들 간에 비동기적으로 데이터를 전달할 수 있는 통신 채널을 구현하는 것이 좋다.  

### pub/sub
레디스의 pub/sub 기능은 가장 간단한 메시징 기능으로, 굉장히 빠르게 동작하며 간단하게 사용할 수 있다.  
1개의 채널에 데이터를 던지면 채널를 구독하고 있는 모든 소비자는 데이터를 빠르게 가져갈 수 있다.  
이때 모든 데이터는 일회성으로 전달된 뒤 삭제된다.  
모든 메시징 상황에 적합하진 않지만 fire-and-forget 패턴이 필요한 간단한 알림 서비스에서는 유용하게 사용할 수 있다.  

### 메시징 큐
레디스의 list 자료 구조는 메시징 큐로 사용되기 알맞다.  
list에서 데이터를 push/pop 할 수 있으며, 애플리케이션에서는 데이터가 있는지 매번 확인할 필요 없이 대기하다가 list에 새로운 데이터가 들어오면 읽어 갈 수 있는
블로킹 기능을 사용할 수도 있다.

### stream
stream은 아파치 카프카 시스템에서 영감을 받아 만들어진 자료 구조로, 데이터는 계속해서 추가되는 방식으로 저장된다.  
카프카처럼 데이터를 읽을 수 있는 소비자 그룹이 존재해 분산 처리도 가능하며, 시간대 별로 검색하는것도 가능하다.  
