# 레디스 클러스와 확장성
스케일 업 vs 스케일 아웃
확장성은 운영 중인 시스템에서 증가하는 트래픽에 유연하게 대응할 수 있는 능력을 뜻한다.  
사용자나 데이터의 증가로 시스템이 처리할 수 있는 트래픽이 많아져야 할 때 용량 및 성능을 늘리기 위해 시스템 확장이 필요한데,
이 때 리소스를 투입하는 방식에 따라 스케일업과 스케일 아웃으로 구분할 수 있다.  

스케일 업이란 서버의 하드에어를 높은 사양으로 업그레이드 하는 것을 말한다.  
보통 서버에 디스크를 추가하거나 CPU나 메모리를 업그레이드함으로써 서버 능력을 증가시키기 때문에 이를 수직 확장이라고도 한다.  

스케일 아웃은 장비를 추가해 시스템을 확장 시키는 방식을 만한다.  
서버의 사양을 업그레이드하는 것으로 한계가 있다면 비슷한 사양의 서버를 추가로 연결해 용량뿐만아니라 처리량도 나눠 성능을 높일 수 있다.  

## 레디스에서의 확장성
만약 레디스를 운영하는 도중 키의 이빅션이 자주 발생한다면 서버의 메모리를 증가시키는 스케입 업을 고려할 수 있다.  
키의 이빅션은 레디스 인스턴스의 max memory 만큼 데이터가 차 있을 때 또다시 데이터를 저장할 때 발생하는 것이므로,
서버의 메모리를 늘리고 레디스 인스턴스의 max memory 값을 증가시키는 스케일 업을 통해 더 많은 데이터를 저장할 수 있다.

하지만 레디스의 처리량을 증가시키고자 할 때 스케일 업만으로는 한계가 있다.
레디스는 단일 스레드로 동작하기 때문에 서버에 CPU 코어가 많아도 단일 스레드의 처리량을 높일 수 없다.  
그러나 데이터를 여러 서버로 분할해 관리하면 다수의 서버에서 요청을 병렬로 처리할 수 있으므로 처리량을 선형적으로 확장 시킬 수 있다.

# 레디스 클러스터의 기능
레디스를 클러스터 모드로 사용하면 추가적인 애플리케이션 아키텍처의 변경 없이 여러 레디스 인스턴스 간 수평 확장이 가능해지며, 데이터의 분산 처리와 복제
자동 페일오버 기능 또한 사용할 수 있다.

## 데이터 샤딩
데이터 저장소를 수평 확장하며 여러 서버 간에 데이터를 분할하는 데이터베이스 아키텍처 패턴을 샤딩이라 한다.  
레디스에서 클러스터 기능을 사용하면 마스터를 최대 1000개까지 확장시킬 수 있다.  
데이터의 샤딩과 관련된 모든 기능은 레디스 냅에서 자체적으로 관리되며, 이를 위한 프록시 서버 등의 추가 아키텍쳐는 필요치 않다.  

클러스터에서 데이터는 키를 이용해 샤딩되며 하나의 키는 항상 하나의 마스터 노드에 매핑된다.
클러스터의 모든 노드는 키가 저장돼야 할 노드를 알고 있기 때문에 클라이언트가 다른 노드에 데이터를 쓰거나 읽으려 할 때 키가 할당된 마스터 노드로 연결을 리디렉션한다.  
이 과정은 레디스 노드와 애플리케이션 쪽의 레디스 클라이언트에서 처리된다.  클러스터에서 노드가 추가/변경 되지 않는 이상 하나의 키는 특정 마스터에 매핑된다.
매번 레디스에 키를 저자할 노드를 질의하지 않게 하기 위해 클라이언트에서는 클러스터 내에서  특정 키가 어떤 마스터에 저장돼 있는지의 정보를 캐싱할 수 있다.

## 고가용성
클러스터는 각각 최소 3개의 마스터, 복제본 노드를 갖도록 구성하는 것이 일반적이며, 하나의 클러스터 구성에 속한 각 노드는 서로 모니터링한다.  
마스터 노드에 장애가 발생하면 이를 인지한 다른 노드들이 마스터에 연결됐던 복제본 노드를 마스터로 자동 페일오버시키기 때문에 사용자의 추가적인 개입없이
레디스의 가용성을 증가시킬 수 있다.

이때 클러스터 내의 노드들은 클러스터 버스라는 독립적인 통신을 이용한다.  
모든 레디스 클러스터 노드는 다른 레디스 클러스터 노드에서 들어오는 연결을 수신하기 위해 추가 TCP 포트가 열려있다.  
클라이언트로부터 커맨드를 받는 TCP 포트와 독립되게 동작하며, 구성 파일에서 clister_bus_port 값을 정의하지 않는다면 
일반적으로 일반 포트에 10000을 더한 값으로 자동 설정된다.
즉 레디스가 6379 포트면 클러스터 버스 포트는 16379가 된다.

클러스터는 모든 노드가 TCP 연결을 사용해 다른 모든 노드와 연결돼 있는 풀 메쉬 토폴로지형태다.  
클러스터 N개의 노드로 이뤄져 있을때 모든 노드는 N-1개의 다른 노드와 송수신 TCP 연결을 하고 있으며, 이 연결은 계속 유지된다.
1개 노드에서 다른 노드로 PING을 보냈을 때 PONG 응답이 늦는다면 해당 노드로의 연결을 새로 시도한다. 

풀 메쉬 토폴로지 형태로 구성된 레디스 클러스터 구조이지만 노드 간 너무 많은 메시지를 교환하는 오버헤드는 걱정안해도 된다.
가십 프로토콜과 구성 업데이트 메커니즘을 이용해 클러스터가 정상적인 상태에서는 노드 간 너무 많은 메시지를 교환하지 않는다.

# 레디스 클러스터 동작 방법

## 해시 슬롯을 이용한 데이터 샤딩
클러스터 구조에서 모든 데이터는 해시슬롯에 저장된다. 
레딧는 총 16384개의 해시 슬롯을 가지며, 마스터 노드는 해시슬롯을 나눠 갖고 있다.
3대의 마스터 노드로 클러스터를 구성했을 때 해시슬롯은 다음과 같이 나눠진다.  
1. 첫 번째 마스터 노드는 0부터 5460까지의 해시슬롯을 포함
2. 두 번째 마스터 노드는 5461부터 10922까지의 해시 슬롯을 포함
3. 세 번째 마스터 노드는 10923부터 16383까지의 해시슬롯을 포함

레디스에 입력되는 모든 키는 하나의 해시슬롯에 매핑 되며, 이때 다음 해시함수는 다음과 같다.
```redis
HASH_SLOT = CRC16(key) mod 16384
```
키를 CRC16으로 먼저 한 번 암호화한 다음 16384라는 값으로 나눈 나머지 값을 이용해 해시 슬롯이 결정된다.  
데이터를 저장할 때뿐만 아니라 데이터를 읽어올 때도 위의 함수를 이용해 커맨드를 처리할 적절한 마스터 노드를 찾아간다.  

ID:8017이라는 키를 가지고 올 때, 알고리즘에 의해 키는 5459라는 해시슬롯에 저장돼 있음을 알 수 있고,
클라이언트는 해시슬롯 5459를 갖고 있는 마스터1에서 데이터를 가지고 올 수 있도록한다.
ID:87345라는 키에 데이터를 저장할 때에도 우선 키가 저장될 해시슬롯이 5462라는 것을 먼저 계산한다.
그 뒤 해당 해시슬롯을 갖고 있는 두 번째 마스터에 데이터를 저장한다.

해시슬롯은 마스터 노드 내에서 자유롭게 옮겨질 수 있으며, 옮겨지는 중에도 데이터는 정상적으로 접근할 수 있다.
이러한 특성으로 인해 하나의 클러스터 내에서 마스터 노드의 추가, 삭제는 굉장히 간단하게 처리될 수 있다.

마스터가 3개이던 클러스터 노드에 1개의 마스터를 추가하는 과정은 신규 레디스 노드를 마스터로 추가한 뒤 기존 노드가 가지고 있던
해시슬롯의 일부를 신규 마스터로 이동 시켜주면 된다.
마스터 노드의 삭제 또한 삭제할 노드가 갖고 있는 해시슬롯을 전부 다른 마스터로 이동시킨 다음 노드를 클러스터에서 제외시키면 된다.

## 해시태그
클러스터를 사용할 때에는 다중 키 커맨드를 사용할 수 없다. 다중 키 커맨드는 MGET과 같이 한 번에 여러 키에 접근해 데이터를 가져오는 커맨드다.
```redis
MGET user1:name user2:name
```

클러스터는 키를 이용해 커맨드를 처리할 마스터로 클라이언트의 연결을 리디렉션하기 때문에 2개 이사의 키에 접근해야 하는 커맨드는 처리할 수 없다.
이때 해시태그라는 기능을 사용하면 이런 문제를 해결할 수 있다.
클러스터에서 데이터는 앞서 설명한 알고리듬을 이용해 키를 해시하기 때문에 키는 랜덤으로 해시슬롯에 배정된다.
하지만 키에 대괄호를 사용하면 전체 키가 아닌 대괄호 사이에 잇는 값을 이용해 해시될 수 있다.
```redis
user:{123}:profile
user:{123}:account
```
위의 두 키는 대괄호 사이에 123이라는 동일한 값을 갖고 있기 때문에 같은 해시슬롯, 즉 같은 마스터에 저장된다는 것이 보장된다.
만약 대괄호 사이에 아무런 문자열이 없다면 다른 키들과 동일하게 전체 키의 문자열로 해싱되며, 여러 개의 {}문자가 포함된 키의 경우 가장 처음의 { 부터 가장 처음의} 사이의 값들이 해싱된다.

|키|해시슬롯|
|---|---|
|user:{123}:profile|123|
|user{}id|user{}id|
|user{{name}}id| {name|
|user{name}{id}|name|
세번쨰의 경우 첫번째{ 부터 첫번쩨 } 안에 있는 값인 {name이 해싱된다.

```redis
MGET {user}1:name {user}2:name
```
하지만 클러스터 구조에서 너무 많은 키가 같은 해시태그를 같고 있다면 하나의 해시슬롯에 데이터가 몰리는 현상이 발생할 수 있기 때문에
키의 분배에 대한 모니터링이 필요할 수 있다.

## 자동재구성
클러스터 구조에서는 데이터를 저장하는 일반 레디스 노드가 서로 감시한다.
모든 노드는 클러스터 버스를 통해 통신하며 인스턴스에 문제가 생겼을 때 자동으로 클러스터 구조를 재구성한다.

레디스 클러스터를 사용할 때 발생하는 재구성은 총 두가지이다.
마스터 노드에 장애가 발생했을 때 복제본 노드를 마스터로 승격시키는 자동 페일오버와 잉여 복제본 노드를 다른 마스터에 연결시키는 복제본 마이그레이션이 있다.

### 자동 페일오버
만약 3개의 마스터 - 슬레이브가 있을때 하나의 마스터가 장애가 일어나면 복제본은 다른 마스터 노드들에게 페일오버를 시도해도 될지 투표를 요청한다.  
투표 요청을 받은 다른 마스터 노드는 마스터가 정상상태가 아니라고 판단할 경우 복제본에게 투표할 수 있으며 과반수 이상 투표를 받은 복제본이 마스터로 승격한다.  

이런 상황에서 다시 새로 승격한 마스터 노드에게 장애가 일어나면 다음 설정에 의해 클러스터 내의 마스터가 하나라도 정상 상태가 아닐 경우 전체 클러스터를 사용할 수 없게 된다.
```redis
cluster-require-full-coverage yes
```

해당 옵션의 기본 값은 yes로 레디스 클러스터에서 일부 해시슬롯을 사용하지 못하게 되면 즉 일부 노드만 다운된 경우라도 데이터의 정합성을 위해 클러스터의 전체 상태가
fail이 돼, 문제가 생긴 해시슬롯을 포함한 전체 해시슬롯에 대한 데이터의 조작도 실패한다.

만약 가용성이 중요한 서비스에서 클러스터 노드의 다운타임을 줄이고 싶다면 자동 복제본 마이그레이션이 가능하도록 아무 마스터 노드에
복제본을 하나 더 추가하는 것을 고려하는 것이 좋다.

### 자동 복제본 마이그레이션
3개의 마스터 - 슬레이브 이고 하나의 마스터에 슬레이브가 2개인 총 7개의 노드로 구성된 클러스터가 있다고 가정하자.  
위의 상황과 마찬가지로 하나의 마스터가 장애를 일으키면 복제본이 마스터로 승격한다.  

이 상황에서 레디스 클러스터는 각 마스터에 연결된 복제본 노드의 불균형을 파악해 2개의 슬레이브 노드가 있는 복제본 중 하나를 
다른 마스터 노드에 연결시키는 작업을 수행한다.  
이를 복제본 마이그레이션이라고한다. 복제본 마이그래이션은 모든 마스터가 적어도 1개 이상의 복제본에 의해 복제되는 것을 보장하며,
이를 이용해 클러스터 전체의 안정성을 향상 시킨다.

이때 아무 복제본이나 마이그레이션되는 것은 아니다. 가장 많은 수의 복제본이 연결된 마스터의 복제본 중 하나가 옮겨지게 되며
FAIL 상태가 아닌 복제본 중 노드 ID가 가장 작은 복제본이 이동될 노드로 선택된다.

```redis
cluster-allow-replica-migration yes
cluster-migration-barrier 1
```

마이그레이션은 cluster-allow-replica-migration 옵션이 yes일때 동작하며, 기본값은 yes이다.  
cluster-migration-barrier 복제본을 마이그레이션하기 전 마스터가 가지고 있어야할 최소 복제본의 수를 의미한다.

예를 들어 이 값이 2로 설정됐을 경우 복제본은 2개를 초과하지 않기 때문에 복제본의 마이그레이션은 발생하지 않는다.

























