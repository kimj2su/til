# 레디스를 캐시로 사용하기
레디스를 캐시로 사용하는 방법에 대해 알아본다.

# 레디스와 캐시

## 캐시란?
캐시란 데이터의 원본보다 더 빠르고 효율적으로 액세스할 수 있는 임시 데이터 저장소를 의미한다.  
다음 조건을 만족시킨다면 캐시를 도입할 때 성능을 효과적으로 개선할 수 있다.

- 원본 데이터 저장소에서 원하는 데이터를 찾기 위해 검색하는 시간이 오래 걸리거나, 매번 계산을통해 데이터를 가져와야 한다.  
- 캐시에서 데이터를 가져오는것이 원본 데이터 저장소 데이터를 요청하는 것보다 빨라야 한다.
- 캐시에 저장된 데이터는 잘 변하지 않는 데이터이다.
- 캐시에 저장된 데이터는 자주 검색되는 데이터이다.

위의 조건을 만족시키는 이상적이 캐시는 애플리케이션이 직면하게 되는 많은 문제점을 해결할 수 있다.

## 캐시로서의 레디스
레디스는 모든 데이터를 메모리에 저장하고 인메모리 데이터 저장소이기 때문에 데이터를 검색하고 반환하는 것이 상당히 빠르다.  
모든 데이터가 메모리 위에 존재하기 때문에 데이터엥 접근하는 시간이 굉장히 빠르다.  
평균 읽기 및 쓰기 작업속도가 1ms 미만이며, 초당 수백만 건의 작업이 가능함을 의미한다.

## 케싱 전략
레디스를 캐시로 사용할때 레디스를 어떻게 배치할 것인지에 따라 서비스의 성능에 큰 영향을 미칠 수 있다.  

### 읽기 전략 - look aside
애플리케이션에서 데이터를 읽어갈 때 주로 사용하는 look aside 전략은 레디스를 캐시로 사용할 때 가장 일반적으로 배치하는 방법이다.  

애플리케이션은 찾고자 하는 데이터가 먼저 캐시에 있는지 확인한 뒤 캐시에 데이터가 있으면 캐시에서 데이터를 읽어 온다.  
이를 캐시 히트라 한다.  
찾고자 하는 데이터가 없으면 캐시 미스가 발생하며 직접 데이터베이스에 접근해 찾고자하는 데이터를 가져온다.  
그 뒤 애플리케이션은 이를 다시 캐시에 저장하는 과정을 거친다.  

look aside의 장점ㅁ은 레디스에 문제가 생겨 접근을 할 수 없는 상항에서도 데이터베이스에서 데이터를 가져올 수 있다는 장점이 있다.  

찾고자 하는 데이터가 레디스에 없을 때에만 레디스에 데이터가 저장되기 때문에 이와 같은 구조를 lazy loading이라고도 부른다.  
매번 레디스에 적재하는 작업을 하면 성능에 영향을 미칠 수 있으므로 캐시로 데이터를 밀어주는 작업을 캐시 워밍(cache warming)이라고도 한다.  


### 쓰기 전략과 캐시의 일관성
캐시는 데이터베이스에서 저장돼 있는 데이터를 단순히 복사해 온 값이다.  
따라서 원본 데이터와 동일한 값을 갖도록 유지하는 것이 필수적이다.  
만약 데이터가 변경되었는데 캐시에는 변경된 값이 반영되지 않는다면 캐시 불일치라한다.

### 1.write through
write through 전략은 데이터베이스에 데이터를 저장할 때 동시에 캐시에도 데이터를 저장하는 전략이다.  
캐시는 매번 최신 데이터를 가질 수 있지만 2개의 데이터베이스에 저장돼야 하기 때문에 데이터를 쓸 때마다 시간이 많이 소요될 수 있다는 단점이 있다.  

이 방법을 사용할 때는 만료시간을 사용할 것을 권장한다.

### 2. cache invalidation
데이터베이스 값을 업데이트할 때마다 캐시에서는 데이터를 삭제하는 전략이다.  
저장소에서 특정 데이터를 삭제하는 것이 새로운 데이터를 저장하는 것보다 훨씬 리소스를 적게 사용하기 때문에 앞선 write through의 단점을 보완한 방법이라고 볼 수 있다.

### 3. write behind(write back)
만약 쓰기가 빈번하게 발생한다면 write behind 전략을 사용하는 것이 좋다.  
데이터베이스에 대량의 쓰기 작업이 발생한다면 많은 디스크 I/O를 유발해, 성능 저하가 발생할 수 있다.  
따라서 먼저 데이터를 빠르게 접근할 수 있는 캐시에 업데이트 한 뒤 이후에는 건수나 특정 시간 간격 등에 따라 비동기적으로 데이터베이스에 업데이트하는 것이다.  

유튜브 좋아요 수는 매번 실시간 집계가 필요하지 않다.  
누군가가 업데이트를 할 때마다 그 데이터가 바로 관계형 데이터베이스에 업데이트 된다면 이는 심각한 성능 저하를 가져올 수 있다.  
좋아요를 누른 데이터를 우선 레디스에 저장해둔 다음 5분 간격으로 이를 집계해 데이터베이스에 저장하는 과정을 거친다면 데이터베이스의 성능을 향상시켜 애플리케이션의 성능도 향상시킬 수 있다.  
물론 이 방법에는 캐시에 문제가 생겨 데이터가 날아갈 경우 최대 5분 동안의 데이터가 날아갈 수 있다는 위험성이 있음을 감수해야 한다.  

# 캐시에서의 데이터 흐름
기본적으로 캐시는 사용자가 자주 사용할 만한 데이터를 갖고 와서 임시로 저장하는 저장소이다.  
그리고 레디스는 메모리를 사용하기 때문에 일정 양의 데이터를 유지해야하고  계속해서 새로운 데이터는 삭제될 수 있도록 관리해야한다. 

## 만료 시간
레디스에서 만료 시간, 즉 TTL(Time To Live)을 설정할 수 있다.  
만료 시간은 일반적으로 초(second) 단위로 표현돠며 특정 키에 대한 만료 시간이 설정 되면 해당 키와 관련된 데이터는 지정된 시간이 지난 후에 레디스에서 자동으로 삭제 된다.  

ttl와 expire 커맨드는  초 단위로 동작하며, pttl과 pexpire 커맨드는 밀리초 단위로 동작한다.
키가 존재하지 않을 때는 -2를 반환하며, 만료 시간이 없을 때는 -1을 반환한다.

```redis
set a 100
expire a 10
ttl a
```
키의 값을 INCR로 바꾸거나 rename을 통해 키의 이름을 바꾸어도 만료시간은 변하지 않는다.  
하지만 기존 키에 새로운 값을 저장해 키를 덮어 쓰면 만료시간도 초기화된다.

```redis
레디스에서 키가 만료 됐다고 해도 바로 메모리에서 삭제되지 않는다.  
키는 passive방식과 active방식으로 삭제된다.  

- passive 방식 : 클라이언트가 키에 접근하고자 할 때 키가 만료됐다면 메모리에서 수동적으로 삭제한다.
                사용자가 접근할 때에만 수동적으로 삭제하기 때문에 아를 passive 방식의 만료라고 한다.
                그러나 사용자가 다시 접근하지 않는 만료키도 있어 이 방식으로는 충분하지 않다.

- active 방식 : ttl 값이 있는 키 중 20개를 랜덤하게 뽑아낸 뒤 만료된 키를 모두 메모리에서 삭제한다.
               만약 25% 이상의 키가 삭제됐다면 다시 20개의 키를 랜덤하게 뽑은 뒤 확인하고, 
               아니라면 뽑아 놓은 20개의 키 집합에서 다시 확인한다. 이러한 과정을 1초에 10번씩 수행한다.
               
만료된 키를 곧바로 삭제하지 않기 때문에 키를 삭제하는 데에 들어가는 리소스를 줄일 수 있지만 그만큼 메모리를 더 사용할 가능성이 존재한다.
최악의 경우 메모리의 1/4는 이미 만료된 키 값일 수 있다.
```

## 메모리 관리와 maxmemory-policy 설정
레디스에서 키에 만료 시간을 설정해 데이터가 자동으로 삭제되도록 함으로써 데이터의 수명을 관리할 수 있다.  
하지만 레디스의 메모리는 제한적이기 때문에 모든 키에 만료 시간을 설정하더라도 너무 많은 키가 저장되면 메모리가 가득차는 상황이 발생할 수 있다.  
메모리의 용량이 가득차면 레디스는 내부 정책을 사용해 어떤 키를 삭제할지 결정한다.  

레디스에서는 데이터의 최대 저장 용량을 설정하는 maxmemory 설정과 이 용량을 초과할 때의 처리 방식을 결정하는 maxmemoty-policy 
설정 값을 사용해 메모리를 관리한다. maxmemory-policy 설정은 다음과 같은 옵션을 사용할 수 있다.

### Noeviction
기본 값이다.   
이 값은 레디스에 데이터가 가득 차더라도 임의로 데이터를 삭제하지 않고 더 이상 레디스에 데이터를 저장할 수 없다는 에러를 반환하는 설정 값이다.  
하지만 레디스에 저장하지 못해 로직에 따라 장애 상황으로 이어질 수 있으며, 이런 상황에서는 관리자가 직접 데이터를 삭제해야하므로 권장하지 않는 방법이다.  

### LRU (Least Recently Used) eviction
레디스에 데이터가 가득 찼을 때 가장 최근에 사용 되지 않은 데이터부터 삭제하는 정책이다.  
최근에 사용하지 않은 것은 나중에도 사용할 가능성이 낮다고 전제한다.  
캐시는 나중에 사용할 가능성이 있는 데이터를 유지하는 것을 목표로 하기 때문에 효율적인 메모리 관리 방식이다.  

- volatile-lru : 만료 시간이 있는 키 중에서만 삭제한다. 만약 만료시간이 있는 키가 없다면 noeviction과 같이 에러를 반환한다.
- allkeys-lru : 레디스 공식문서에서는 레디스를 캐시로 사용할 때 잘 모르겠다면 해당 방식을 사용하길 권장한다.  
               만료시간이 있는 키와 없는 키 모두 삭제한다.

### LFU (Least Frequently Used) eviction
레디스에 데이터가 가득 찼을 때 가장 자주 사용되지 않은 데이터부터 삭제하는 정책이다.  

LFU는 LRU와 유사하지만 키를 액세스하는 패턴에 따라 우선순위가 유동적으로 바뀐다는 점에서 특정 케이스에서는 LRU보다 효율적일 수 있다.  
키가 오랫동안 사용되지 않았더라도 과거에 자주 사용했던 키라면 나중에 다시 사용될 가능성이 높다고 판단해 우선순위가 높아지게 된다.  

- volatile-lfu : 만료 시간이 있는 키 중에서만 삭제한다. 만약 만료시간이 있는 키가 없다면 noeviction과 같이 에러를 반환한다.
- allkeys-lfu : 만료시간이 있는 키와 없는 키 모두 삭제한다.

## RANDOM eviction
이 옵션은 레디스에 저장된 키 중 하나를 임의로 골라내 삭제한다.  
위의 알고리듬을 사용하지 안기 때문에 삭제될 키 값을 계산하지 않아도 된다는 장점이 있다.  
권장하지 않는다.

## volatile-ttl
만료 시간이 가장 작은 키를 삭제한다.  
삭제 예정 시간이 얼마 남지 않은 키를 추출해 해당 키를 미리 삭제하는 옵션이다.  

# 캐시 스탬피드 현상
대규모 트래픽 환경에서 만료 시간을 어떻게 설정하느냐에 따라 캐시 스탬피드와 같은 예상치 못한 상황이 발생할 수 있다.  
여러 개의 애플리케이션에서 바라보던 레디스에서 키가 만료되면 이 서버들은 한꺼번에 데이터베이스를 조회하게 된다.  
이를 중복 읽기라한다.  
이 후 각 애플리케이션은 레디스에 데이터를 쓰게 되는데 이때 중복 쓰기가 발생한다.  
이런걸 캐시 스탬피드라고 한다.  

## 적잘한 만료 시간 설정
캐시 스탬피드를 줄이기 위한 가장 간단한 방법은 만료 시간을 너무 짧지 않게 설정하는 것이다.  

## 선계산
look aside 방식으로 캐시를 사용할 때 애플리케이션은 캐시에 데이터가 있는지 확인한 뒤, 데이터베이스에서 데이터를 가져온 뒤
레디스에 저장한다.  
캐시 스탬피드가 문제되는 이유는 데이터가 만료되는 시점에 동시다발적으로 이를 인지하고, 이 후 작업을 동시에 작업하기 때문이다.  
만약 키가 만료되기전에 이 값을 미리 갱신해준다면 불필요한 프로세스를 줄일 수 있다.

## PER 알고리즘
PER(Probabilistic Early Recomputation) 알고리즘은 만료 시간이 다가올 때 미리 데이터를 갱신하는 방법이다.  

```redis
currentTime - (timetoCompute * beta * log(rand())) > expirationTime
```

- currentTime : 현재 남은 만료 시간
- timetoCompute : 데이터를 갱신하는데 걸리는 시간
- beta : 기본적으로 1.0보다 큰 값으로 설정 가능
- rand() : 0과 1 사이의 난수
- expirationTime : 만료 시간

timeToCompute * beta * log(rand())는 무작위성을 가진 값이며, 이 값은 항목의 만료 여부에 영향을 미친다.  
만료 시간이 가까워 질 수록 currentTime 과 expire 사이의 차이가 작아지며, rand() 함수가 반환한 무작위 값에 의존하기 때문에
조건이 참이 될 확률이 높아진다.  
이것은 만료 시간이 점점 다가올 때 더 자주 만료된 캐시 항목을 확인하게 되는 것을 의미한다.
애플리케이션에서 만료시간이 가까워질 수록 true를 반환할 확률이 증가하므로 불필요한 계산을 효과적으로 방지하게 된다.  
따라서 데이터를 가져오는 GET 대신 이 함수를 사용하여 캐시 스탬피드 현상을 줄이고 성능을 최적화하는데 도움이 된다.  

# 세션 스토리지로서의 레디스
 
## 세션이란?
세션이란 서비스를 사용하는 클라이언트의 상태 정보를 의미한다.  
유저가 로그인해 있는 동안에는 세션의 데이터를 끊임없이 읽고 쓰게 되므로 빠른 응답 속도는 필수적이다.  
또한 레디스는 키-값 형식으로 string, set, hash등의 자료구조를 제공하여 저장하기 용이하다.  

## 세션 스토리지로서이 필요한 이유
트래픽이 늘어 여러개의 웹 서버를 사용하여 트래픽을 분산하게 된다.  
이때 각 웹서버별로 세션 스토어를 따로 관리하면 유저의 세션 정보를 갖고 있는 웹 서버에 종속 돼야 한다.  
쇼핑 카트에 아이템을 저장했는데 재 접속할때마다 없어지는 데이터 정합성이 깨지게 된다.  
결국 이렇게 되면 트래픽을 분산할 수 없는 sticky session이 되어버린다.  
all-to-all 방법은 유저를 여러 웹 서버에 분산 시킬 수 있지만 유저의 세션 데이터는 여러 서버로 복사돼 저장되기 때문에 불필요한 공간을 차지하게 된다.  

또 데이터베이스를 세션 스토어로 사용하는 방법이 있다.  
유저는 세션이 활성화돼 있는 동안 세션 스토어에 활발하게 액세스한다.  
만약 세션 스토어의 응답 속도가 느려지면 이는 곧 바로 클라이언트의 오류로 이어진다.  
서비스가 커져갈 수록 데이터베이스를 세션 스토어로 사용하는 것은 서비스 전반적인 응답 속도를 저하시키는 요인이 될 수 있다.  

이때 레디스를 세션 스토어로 사용한다.
유저는 세션 스토어에 구애 받지 않고 어떤 웹 서버에 연결되더라도 동일한 세션이 데이터를 조회할 수 있어 트래픽을 효율적으로 분산시킬 수 있다.  

레디스의 hash 구조는 세션 데이터를 저장하기에 알맞은 형태이다.  

```redis
hmset usersession:1 Name Jisu IP 10.10.10.1 Hits 1
hincrby usersession:1 Hits 1

hget usersession:1 Name
hget usersession:1 IP
hget usersession:1 Hits
```

## 캐시와 세션의 차이
레디스를 캐시로 사용할 때 look aside 전략을 이용할 때는 완벽한 데이터베이스의 서브셋으로 동작한다.  
캐시가 갖고 있는 값은 데이터베이스에 있으며 따라서 캐시 내부의 데이터가 유실되더라도 해당 데이터는 데이터베이스에서 찾을 수 있다.  
캐시에 저장된 데이터는 여러 애플리케이션ㄴ에서 함께 사용할 수 있다. 여러 애플리케이션이 함께 사용할수록 더 효율적이다.  
하지만 세션 스토어에 저장된 데이터는 공유되지 않으며 특정 사용자 ID에 한해 유효한다.  

유저가 최근 봤던 아이템, 혹은 장바구니에 담긴 아이템은 세션 스토어에만 담겨 있다.  
유저가 로그아웃할때 세션은 종료되며 이 때 데이터의 종류에 따라 데이터베이스에 저장해 영구적으로 보관할 것인지,  
삭제할것인지 결정된다.  
최근에 봤던 상품 리스트는 휘발시켜도 되지만 장바구니에 담아 놨던 상품은 데이터베이스에 저장시켜 다음에 로그인했을때 확인할 수 있도록 해야 한다.
