# sorted set을 이용한 실시간 리더보드
리더보드란 경쟁자들의 순위와 현재 점수를 보여주는 순위표를 의미한다.  
개임 외의 서비스에서도 여러 데이터들을 게임화해 리더보드로 나타내는 방식을 자주 사용한다.  

리더보드에는 두 가지 유형이 있다.  
절대적 리더보드는 서비스의 모든 유저를 정렬시켜 상위권의 목록만을 표시한다.  
상대적 리더보드는 사용자마다 다른 데이터를 보여준다.  
상대적 리더보드는 사용자의 스코어를 기반으로 그들을 다른 사용자와 비교해 순위를 결정하는 형태의 리더보드이다.  

예를 들어 내가 100등이라면 98등, 99등, 100등(나), 101등, 102등 등의 사용자들의 점수를 보여주는 것이다.  
또 판교내 직장인들 중에서 내가 몇 번째로 빠르게 출근했는지를 보여주는 것도 상대적 리더보드의 예라고 할 수 있다.  

리더보드는 기본적으로 사용자의 스코어를 기반으로 하기 때문에 사용자가 증감함에 따라 가공해야 할 데이터가 몇배로 증가한다.  
레디스의 sorted set은 데이터를 저장할 시점부터 정렬되어 들어간다.  
만약 유저의 스코어를 sorted set의 가중치로 설정한다면 스코어 순으로 정렬되기 때문에 데이터를 읽어로때 정렬할 필요가 없다.  

## sorted set을 이용한 일별 리더보드
서비스에 일별 리더보드를 도입하기 위해 daily-score:<날짜>를 이용해 sorted set 키를 만들고 스코어를 가중치로 설정하자.  

### 데이터 삽입
```redis
zadd daily-score:240209 28 player:286
zadd daily-score:240209 400 player:234
zadd daily-score:240209 45 player:101
zadd daily-score:240209 357 player:24
zadd daily-score:240209 199 player:143
```

### 데이터 조회
위의 데이터는 저장할때 부터 정렬되어 들어가므로 zrange 커맨드로 조회하면 오름차순으로 정렬된데이터를 확인할 수 있다.
```redis
zrange daily-score:240209 0 -1 withscores

 1) "player:286"
 2) "28"
 3) "player:101"
 4) "45"
 5) "player:143"
 6) "199"
 7) "player:24"
 8) "357"
 9) "player:234"
10) "400"
```

### 데이터 내림차순 조회
만약 첫 화면이 오늘의 상위 랭커 3명을 보여주는 것이라면 zrevrange 커맨드를 사용해 내림차순으로 조회할 수 있다.
```redis
zrevrange daily-score:240209 0 2 withscores

 1) "player:234"
 2) "400"
 3) "player:24"
 4) "357"
 5) "player:143"
 6) "199"
```

### 데이터 업데이트
만약 사용자의 스코어가 변경되었다면 zadd 커맨드를 사용해 업데이트할 수 있다.
```redis
zadd daily-score:240209 200 player:286
(integer) 0

zrange daily-score:240209 0 -1 withscores
 1) "player:101"
 2) "45"
 3) "player:143"
 4) "199"
 5) "player:286"
 6) "200"
 7) "player:24"
 8) "357"
 9) "player:234"
10) "400"
```
기본적으로 set이기 때문에 데이터는 중복으로 저장되지 않고
가은 아이템을 저장하고자 할 때 스코어가 다르면 기존 데이터의 스코어만 신규 입력한 스코어로 업데이트된다.  
그리고 다시 정렬된다.  

직접 스코어의 값을 지정하지 않고 ZINCRBY 커맨드를 사용해 스코어를 증가시킬 수도 있다.
```redis
zincrby daily-score:240209 100 player:24

 1) "player:101"
 2) "45"
 3) "player:143"
 4) "199"
 5) "player:286"
 6) "200"
 7) "player:234"
 8) "400"
 9) "player:24"
10) "457"
```

## sorted set을 이용한 주간 리더보드
주간 리더보드는 매주 월용일마다 초기화 된다고 가정한다.  
24년 2월 9일 금요일에 주간 리더보드를 확인하면 5, 6, 7, 8, 9일 5일간의 데이터를 보여준다.  
관계형 데이터베이스에서 이를 구현하려면 하나의 테이블에서 일자에 해당하는 데이터를 모두 가져온 뒤 선수별로 합치고
이를 다시 소팅하는 작업을 해야 된다.  

레디스에서는 zunionstore 커맨드를 사용해 여러 sorted set을 합칠 수 있다.
zunionstore 커맨드는 지정한 키에 연결된 각 아이템의 스코어를 합산하는 커맨드다.  
따라서 해당하는 일자의 키를 지정하기만 하면 손쉽게 주간 리더보드 데이터를 구할 수 있다.

### 랭킹 합산 - zunionstore
24년 02월 09일의 주간 리더보드를 구하려면 5일간의 데이터를 합산해야 한다.

```redis
zunionstore <생성할 키 이름> <합산할 키 개수> <합산할 키> ... <옵션>
zunionstore weekly-score:240209 5 daily-score:240205 daily-score:240206 daily-score:240207 daily-score:240208 daily-score:240209
(integer) 5

zrevrange weekly-score:240209 0 -1 withscores
 1) "player:24"
 2) "457"
 3) "player:234"
 4) "400"
 5) "player:286"
 6) "200"
 7) "player:143"
 8) "199"
 9) "player:101"
10) "45"
```
스코어가 같을 때 사전순으로 정렬되며 zrevrange 커맨드를 사용해 내림차순으로 조회할 수 있다.  

### zunionstore 가중치 옵션
만약 2월 5일 월요일에 두배이벤트를 했다면 해당 데이터에만 가중치를 두배로 늘려 계산할 수 있다.

```redis
zunionstore weekly-score:240209 5 daily-score:240205 daily-score:240206 daily-score:240207 daily-score:240208 daily-score:240209 WEIGHTS 2 1 1 1 1
```

## sorted set을 이용한 최근 거색 기록
최근 검색기록을 관계형 데이터베이스로 구현하려하면 어떻게 할까?  
요구사항은 다음과 같다.

- 유저별로 다른 키워드 노출
- 검색 내역은 중복 제거
- 가장 최근 검색한 5개의 키워드만 사용자에게 노출

```redis
select * from keyword where user_id = 123 order by reg_date desc limit 5
```
매번 배치를 통해 데이터를 지워주고 이렇게 쿼리를 날려야 한다면 검색기록이 많아질수록 성능이 떨어질 것이다.

레디스의 sorted set을 사용하면 이를 쉽게 구현할 수 있다.  
set이기 때문에 중복자료는 저장되지 않고 스코어로 시간을 사용한다면 검색 기록으로 정렬 될 수 있다.  

만약 유저 아디가 123인 유저의 검색 기록을 search-keyword:123이라는 키에 sorted set으로 저장한다고 하자.  
데이터를 저장할때 유저가 저장한 시간을 스코어로 지정한다면 검색 시간 순으로 정렬된 데이터가 저장된다.
2024년 02월 09일 13시에 "레디스"라는 키워드를 검색했다면 다음과 같이 저장할 수 있다.

```redis
zadd search-keyword:123 20240209130000 레디스

zrevrange search-keyword:1233 0 4 withscores  // 최근 5개의 검색기록 조회
 1) "레디스"
```
만약 여기서 한글이 깨진다면 redis-cli --raw 옵션을 사용하면 된다.  
중복 검사할 필요도 없고 정렬에 대한 고민도 없다.  
sorted set 데이터 구조는 중복을 허용하지 않고 스코어로 정렬되기 때문이다.  

### 데이터 삭제
최근 5개의 검색기록만 반환하면 되니 6번째 부터는 필요가 없다.  
시간순으로 정렬되니 가장 오래된 데이터를 지우기 위해서는 데이터가 6개째 저장되었을때 가장 오래된 데이터인 0번 인덱스의 데이터를 삭제하면 된다.  
이때 sorted set의 음수 인덱스를 사용해서 데이터를 삭제하면 된다.  
음수 인덱스는 아이템의 가장 제일 마지막 값을 -1로 시작해서 역순으로 증가하는 값이다.  
    
```redis
zremrangebyrank <kek> <start> <stop>
zremrangebyrank search-keyword:123 -6 -6
```

## sorted set을 이용한 태그 기능
블로그에 게시물을 작성할 때 태그를 추가한다고 한다.  
관계형 데이터베이스에서는 최소 2개의 테이블이 필요하다. 태그, 태그 - 게시물 테이블이다.  
레디스에서 set을 사용하면 굉장히 간단하게 게시물의 태그 기능을 사용할 수 있다.

```redis
sadd post:1:tags IT REDIS NOSQL
sadd post:2:tags IT JAVA
```
태그 기능을 사용하는 이유 중 하나는 특정 게시물이 어떤 태그와 연관돼 있는지 확인하는 것 뿐만 아니라 특정한 태그를 포함한 게시물들만 확인하기 위해서일 수 있다.  
위와 같이 포스트 기준으로 태그를 저장할 수도 있고 아래와 같이 태그를 기준으로 포스트를 저장할 수도 있다.

```redis
sadd tag:IT:posts 1
sadd tag:REDIS:posts 1
sadd tag:NOSQL:posts 1
sadd tag:IT:posts 2
sadd tag:JAVA:posts 2
```

### 태그별 게시물 조회

smembers 커맨드를 사용해 태그별로 게시물을 조회할 수 있다.
```redis
smembers post:1:tags
 1) "IT"
 2) "REDIS"
 3) "NOSQL"

smembers post:2:tags
 1) "IT"
 2) "JAVA"
 
smembers tag:IT:posts
smembers tag:REDIS:posts
smembers tag:NOSQL:posts
 1) 1
 
smembers tag:JAVA:posts
smembers tag:IT:posts
 1) 2
```

sninter 커맨드를 이용하면 특정 set의 교집합을 확인할 수 있다.  
만약 IT를 포함한 게시물을 찾고 싶다면 다음과 같이 사용할 수 있다.
```redis
sinter tag:IT:posts 
 1) 1
 2) 2

IT와 REDIS를 포함한 게시물을 찾고 싶다면 다음과 같이 사용할 수 있다.
sinter tag:IT:posts tag:REDIS:posts
 1) 1
```

```redis
select post_id from tag_post where tag_id In (1, 3) group by post_id having count(tag_id) = 2
```
RDMS에서는 위와 같은 쿼리를 사용해 태그별로 게시물을 조회할 수 있다.

## 랜덤 데이터 추출
게임에서 랜덤으로 게임 유저를 매핑하거나 이벤트에 응모한 유저를 랜덤으로 추출하거나 가챠에서 랜덤으로 아이템을 뽑는 등의 로직을 구현하는 것을 가정해본다.  
관계형 데이터베이스에서는 랜덤으로 데이터를 추출하기 위해 order by rand()를 사용한다.  
여기서 limit을 사용해 랜덤으로 몇개의 데이터를 추출할지 지정할 수 있다.  
데이터가 얼마냐에 따라 성능이 나빠지게 되므로 굉장히 부하가 많이 가는 방법일 수도 있다.  

레디스에서는 randomkey 커맨드를 사용해 O(1)의 시간 복잡도로 랜덤으로 키를 추출할 수 있다.  
하지만 위의 명령어는 한가지 종류의 데이터만 사용하지 않으므로 다른 명령어를 사용한다.  
hrandfield, srandmember, zrandmember 는 각각 hash, set, sorted set에 저장된 아이템 중 랜덤한 아이템을 추출할 수 있다.  

전체 유저를 user:hash라는 키의 hash에 저장했다고 가정하자.  
이때 필요한 유저의 id, 값을 유저명으로 저장한다고 가정하자.  

hrandfield 커맨드를 사용하면 랜덤한 유저의 id를 추출할 수 있다.
```redis
hrandfield user:hash
hrandfield user:hash 1 withvalues // count 옵션을 사용해 랜덤한 유저의 id와 값을 추출할 수 있다.
```
count 옵션을 양수로 하면 중복되지 않는 랜덤 데이터가 나오지만 음수로 하면 중복된 데이터가 나올 수 있다.  


## 레디스에서의 다양한 카운팅 방법

### 좋아요 처리하기
실시간 트래픽이 굉장히 많은 사이트라면 하나의 뉴스 댓글에 좋아요가 눌리는 일은 1초에 몇만 개 이상 발생할 수 있다.  
좋아요를 누를 때마다 관계형 데이터베이스 테이블의 특정 행에서 좋아요 개수 데이터를 증가시키는 일은 직접적인 영향을 끼칠 수 있다.  
또한 하나의 유저는 한번의 좋아요를 누를 수 있어야 하기 때문에 단순히 좋아요의 개수를 파악하는것이 아니라 검증을 해야 한다.  

이는 레디스의 set을 통해 간단히 구현할 수 있다.  
댓글 id를 기준으로 set을 생성한 뒤, 좋아요를 누른 유저의 id를 set에 저장하면 중복 없이 데이터를 저장할 수 있다.  
댓글 id가 1에 좋아요를 누른 유저는 1, 2, 3이다.
```redis
sadd comment-id:1 1 2 3

scard comment-id:1
3
```

### 읽지 않은 메시지 수 카운팅 하기
채팅 애플리케이션에서 사용자가 속한 채널별로 읽지 않은 메시지를 카운팅하고 관리하려고 한다.  
바로 관계형 데이터베이스에 I/O를 하지 않고 일시적으로 레디스와 같은 인 메모리 데이터베이스에 일시적으로 저장한 뒤 
필요한 시점에 한꺼번에 업데이트하는 방식을 사용해서 관계형 데이터베이스의 부하를 최소화하고 성능을 향상 시키고자 한다.  

단순하게 채널에 새로 추가된 메시지의 개수를 확인하면 된다.  
따라서 사용자의 ID를 키로 사용하고, 채널의 ID를 아이템의 키로 활용해 숫자 형태의 메시지 카운트를 관리하는 방법을 고려할 수 있다.  

사용자 1이 속한 채널 1에 3개의 메시지가 추가되었다고 가정하자.
```redis
hincrby user:1 channel:1 3
```
만약 누군가가 이미 전송한 메시지를 삭제했다면 음수를 입력하여 데이터를 감소 시킨다.
```redis
hincrby user:1 channel:1 -1
```

hash 구조는 객체 구조에서의 카운트를 효과적으로 관리할 수 있는 방법이다.  
이 구조를 활용하면 사용자를 식별하고 해당 채널을 찾아가서 데이터를 업데이트 하는 작업이 직관적이면서도 간단히 수행된다.  
이러한 간결한 데이터 구조는 성능을 향상시키며 복잡성을 줄일 수 있다.  

## DAU 구하기
DAU(Daily Active User)는 하루 동안 서비스에 방문한 사용자의 수를 의미한다.  
하루에 여러번 방문했다 하더라도 한번으로 카운팅 되는 값으로, 실제 서비스를 이용한 사용자의 유니크한 수를 파악할 수 있는 지표다.  
사용자의 동향과 마케팅을 위한 자료로 활용도기도 한다.  

애플리케이션의 사용자의 접근 로그와 같은 접속 로그를 활용해 날마다 배치 처리를 수행하는 방식으로 DAU를 계산할 수는 있지만 이런 방식으로는 실시간 데이터는 얻을 수 없다.  
set을 활용할 수도 있지만 사용자가 많아 1000만명이 넘는다면 보통 하나의 키에 200~300만개 까지 조정할 것을 권장하는 넘어 성능 저하로 이어질 수 있다.  
-> 메모리 차지 문제도 있다.  

레디스의 비트맵을 활용하면 메모리를 효율적으로 줄이며어도 실시간으로 서비스의 DAU를 확인할 수 있다.  
레디스에서 비트맵은 별개의 자료구조로 존재하는것은 아니고 string 자료 구조에 bit 연산을 할 수 있도록 구현되어 있다.  

### 비트맵을 이용한 DAU 구하기
하루에 1천만영이 넘는 게임 서비스에서 레디스의 bit를 사용해 DAU를 측정하는 방법을 알아보자.  
이때 사용자의 id값은 0이상 정수값이어야 한다.  

1천만명의 사용자 id는 string 구조로 1천 만개의 비트로 나타낼수 있으며, 
이는 대략 1.2mb 크기에 해당한다.  
레디스에서 string의 최대 길이는 512MB이므로 하나의 키를 사용해 1천만명의 사용자를 카운팅하는것은 문제없이 가능하다.  

2024년 02월 09일에 방문한 유저id를 구하기 위해서는 uv:20240209인 데이터를 만든 뒤 접속한 유저의 id의 bit를 1로 설정하면 된다.  
id가 14인 유저가 접근했을 때에는 다음과 같이 오프셋 14fmf 1로 설정하면 된다.  
```redis
setbit uv:20240209 0 1
setbit uv:20240209 14 1
bitcount uv:20240209
2
```

비트맵에서 bitop 커맨드를 사용하면 and, or ,xor, not 연산을 할 수 있으며 레디스 서버에서 바로 계산된 결과를 가져올 수 있다.  

### 일주일 동안 출석 이벤트 구현하기
게임에서 출석 이벤트를 진행하기 위해 특정 기간 동안 매일 방문한 사용자를 구하고 싶을 수 있다.  
2월 5일 부터 7일까지 매일 출석한 유저에게 보상을 주기 위해 일주일 동안 매일 출석한 유저를 구하는 방법을 알아본다.

```redis
setbit uv:20240205 0 1
setbit uv:20240206 0 1
setbit uv:20240207 0 1

bitop and event:20240209 uv:20240205 uv:20240206 uv:20240207
```
bitop and 커맨드를 사용하면 3일 연속 출석한 유저의 정보를 새로운 비트맵 event:20240209 를 얻을 수 있다.  
비트맵 데이터는 애플리케이션에서 list 자료로 변환해 사용할 수 있다.  
위 이벤트의 결과 데이터만 event:20240209을 확인해보자

비트맵은 사실상 string 자료구조로 저장되기 때문에 get 키워드를 사용해 저장된 데이터를 확인할 수 있다.

## hyperloglog를 이용한 애플리케이션 미터링
클라우드 환경에서 미터링은 중요한 과제가 됐다.  
클라우드 컴퓨팅의 특성중 하나는 Pay as you go로 사용한 만큼 지불한다.  
따라서 서비스의 사용량을 정확하게 파악하는 것은 매우 중요하다.  
미터링 솔류션은 사용자의 서비스 사용 내역을 이용하기 때문에 대용량 데이터를 처리할 수 있어야 한다.  
서비스의 규모에 따라 초당 수천 건 이상의 작업이 발생할 수 있으며, 따라서 미터링 솔루션은 높은 처리량과 낮은 대기 시간을 가져야한다.  

1초에 100개씩 로그가 쌓이는 서버가 존재한다고 가정한다.  
한시간이면 36만개의 로드 한달이면 2억 6천개 정도의 로그가 쌓일 수 있다.  
이런 서버가 한 대가 아니라 여러 대 존재한다면 총 몇 개의 로그가 쌓였는지 측정하는 그 자체는 큰 부하가 될 수 있다.  

다음 조건을 만족한다면 hyperloglog를 사용할 수 있다.  
- 집합 내의 유일한 데이터베이스 개수를 카운팅해야 한다.
- 1% 미만의 오차는 허용 가능하다.
- 카운팅 할 때 사용한 정확한 데이터를 다시 확인하지 않아도 된다.  

일반적인 방법으로 는 중복을 피하가 위해 저장된 데이터를 모두 기억해야하지만 그럴 수록 메모리를 많이 사용하게 된다.  
하지만 값을 다시 확인하지 않아도 되는 경우라서 hyperloglog를 이용할 수 있다면 최소한의 메모리만을 사용해 중복 되지않는 데이터의 개수를 계산할 수 있다.  

### 레디스의 hyperloglog를 이용해 유저의 월별 API 호출 횟수를 계산하는 방법
각 유저를 구분하는 ID를 키로 사용하고 API 호출할 때마다 저장되는 로그의 식별자를 hyperloglog에 저장한다.  
예를 들어 2024년 2월 10일 ID가 245인 유저의 호출 횟수를 계산하려면 API를 호출할 때마다 20240210:user:245라는 키에 PFADD 커맨드를 사용해 로그 식별자를 저장하면 된다.

```redis
pfadd 20240210:user:245 api:1
pfadd 20240210:user:245 api:1
pfadd 20240210:user:245 api:2

pcount 20240210:user:245
2
```
pcount를 하면 2가 반환된다. 가본적으로 set과 같이 중복을 허용하지 않지만 12KB로 데이터의 크기가 고정되어 있어 공간을 효율적으로 사용할 수 있다.    

pmerge 커맨드를 사용하면 여러 hyperloglog를 하나로 합칠 수 있다.
```redis
pmerge 2024:user:245 202402:user:245 20240210:user:245
"OK"

pcount 2024:user:245
```

## Geospatial Index를 위용한 위치 기반 애플리케이션 개발

### 위치 데이터란
위치 데이터는 주로 경도와 위도(x, y) 좌표 쌍으로 표현 되며, 이러한 공간 데이터를 처리하는 곳운 개발 과정에서 쉽지 않은 과제 중 하나 이다.  
특히 사용자의 위치가 실시간으로 변할 때 이데이터를 신속하게 저장하고 처리할 수 있는 데이터 저장소는 다음과 같은 기능을 제공해야 한다.

- 사용자의 현재 위치 파악
- 사용자의 이동에 따른 실시간 변동 위치 업데이트
- 사용자의 위치를 기준으로 근처의 장소 검색


### 레디스에서의 위치 데이터
레디스는 geo 자료 구조를 통해 공간 정보 데이터를 처리할 수 있다.  
geo set과 pub/sub을 이용해서 특정 맛집에서 이벤트를 발생시킬때 해당 지역 근처의 사용자에게 실시간 알림을 보내는 서비스를 간단하게 구축할 수 있다.  

### geo set
공간 관리에 특화된 데이터 구조로 각 위치 데이터는 경도와 위도의 쌍으로 저장된다.  
이 데이터는 내부적으로 sorted set으로 저장된다.

```redis
geoadd <key> <longitude> <latitude> <member> ...
geoadd user 50.00 13.41 142
```
Id가 142인 사용자의 현재 위치 정보를 geoadd 커맨드를 사용해서 추가할 수 있다.  

변경시에도 geoadd 커맨드를 사용해 업데이트할 수 있다.
기존 데이터는 새로운 위치 데이터로 업데이트 된다.  

프라하의 맛집 ukalendu를 restaurant라는 키에 저장한다고 가정하자.
```redis
geoadd restaurant 50.00 13.41 ukalendu

// 저장죈 데이터 조회
geopos restaurant ukalendu

// 호텔 근처의 식당을 찾고자 한다면 , 호텔의 경도와 위도 값을 가져온 뒤 가음과 같이
// geosearch 커맨드로 검색하면 1km 내에 있는 식당을 찾을 수 있다.
geosearch reataurant fromlomlat 50.00 13.41 byradius 1 km
```
fromlonlat은 검색을 시작할 위치의 경도와 위도를 의미하고 byradius는 검색할 반경을 의미한다.
fromlonlat 옵션을 이용해 직접 경도와 위도를 지정한뒤 해당 위치 근처 1km 내의 데이터를 검색했다.  
동일한 데이터 세트 내에서 검색하는 경우 frommeber 옵션을 이용하면 경도와 위도를 직접 입력하지 않고도 데이터를 찾을 수 있다.  

byradius옵션은 지정한 반지름 값을 기준으로 해당위치에서 그 반지름 만큼 떨어진 범위 내의 데이터를 검색한다.  
반면 bybox옵션은 width와 height 값을 추가로 지정함으로써, 특정 위치를 중심으로 한 직사각형 영역 내의 장소들을 검색할 수 있다.  
bybox를 사용할때 width, hight를 설정하면 검색 범위가 기준점을 중심으로 좌우 width 만큼 상하로 height만큼의 거리를 포함하는 직사각형 영익으로 결정된다.  

```redis
geosearch restaurant frommember ukalendu bybox 4 2 km
```
width 4km height 2km로 설정하면 검색 범위는 기준점을 중심으로 양옆으로는 2km, 1km 위 아래오는 1km 내에 데이터를 검색한다는 의미이다.  
즉 4 * 2km의 직사각형 영역 내에 있는 데이터를 검색한다.  
byradius는 검색 위치를 기준으로 입력한 데이터만큼 떨어진것이 아니라는 점을 유의해야함.
