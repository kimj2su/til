# 레디스 에서 데이터를 영구 저장하기
레디스에서 모든 데이터는 메모리에서 관리된다.  
따라서 인스턴스 혹은 레디스가 실행되는 서버의 장애로 인해 레디스 인스턴스가 재 시작될 경우 메모리에 상주하는 데이터는 손신될 가능성이 있다.  
백업과 복제는 다르다.  
복제는 가용성을 위한 것이며 백업은 장애 상황에서 데이터의 복구를 위해 필요하다.  

레디스를 캐시가 아닌 영구 저장소와 같은 용도로 사용한다면 디스크에 데이터를 주기적으로 백업하는것이 안전하다.  
데이터를 안전하게 저장하기 위해 레디스에서는 RDB와 AOF라는 두 가지 방식을 제공한다.
- AOF(Append Only File) : 레디스 인스턴스가 처리한 모든 쓰기 작업을 차례대로 기록, 복원 시에는 파일을 다시 읽어가며 데이터 세트 재구성
- RDB(Redis Database) : 일정 시점에 메모리에 저장된 데이터 전체를 저장(snapshot 방식)
```redis
set key1 a
set key1 apple
set key2 b
del key2
```
위와 같은 명령어를 했을 때 두 개의 방식이 어떻게 동작되는지 본다.
- AOF : 모든 명령어를 기록하기 때문에 모든 명령어를 기록한다.
  - set key1 a
  - set key1 apple
  - set key2 b
  - del key2
- RDB : 일정 시점에 스냅샷을 저장하기 때문에 마지막 스냅샷 이후의 명령어만 기록한다.
  - key1 -> apple

위에는 이해하기 위한 예시이며 실제로는 RDB파일은 바이너리 형태로 저장돼 알아볼 수 없는 형태이고 
AOP는 레디스 프로토콜RESP형태로 저장된다.  

aof파일에는 레디스에서 실행된 모든 쓰기 작업이 기록된다. 처음부터 끝까지 따라가면 원본 데이터에 도달할 수 있다.  
rdb 파일에는 저장되는 시점의 메모리 데이터가 그대로 저장된다.  
사진을 찍듯 메모리의 데이터를 그대로 내려쓰기 때문에 스냅샷 방식이라고도 하며 위 예시의 커맨드를 모두 실행한 뒤 RDB 파일을 생성한다면  
실제로 메모리에 저장된 값인 key1 - apple이라는 데이터만 남아 있게 된다.  
RDB파일의 경우 시점 단위로 여러 백업본을 저장할 수 있고 aof 파일보다 복원이 빠르다는 장점이 있지만 특정 시점으로의 복구는 불가능하다.  
AOF는 RDB파일보다 크기가 크고 주기적으로 압축해 재작성해야하지만 원하는 시점으로 복구할 수 있다는 장점이 있다.  

하나의 인스턴스에서 두 가지 옵션을 동시에 사용하는것도 가능하며, 일반적인 RDB만큼의 데이터 안정성을 원하는 경우 두 가지 백업 방식을 동시에 사용하기를 권장한다.  

레디스에서 데이터를 복원할 수 있는 시점은 서버가 재시작될 때뿐이며, 레디스 인스턴스의 실행 도중에 데이터 파일을 읽어올 수 있는 방법은 없다.  

레디스 서버는 재시작될 때 aof 파일이나 rdb파일이 존재하는지 확인한 뒤, 파일이 있을 때에는 파일을 로드한다.  
레디스는 rdb 파일보다 aof 파일이 더 내구성이 보장된다고 판단하기 때문에 2개의 파일이 모두 존재할 때에는 aof이 데이터를 로드한다.

# RDB 방식의 데이터 백업
RDB 파일은 레디스에서 데이터를 백업하기 위한 가장 단순한 방법이다.  
원하는 시점에 메모리 자체를 스냅숏 찍듯 저장할 수 있기 때문에 백업에 적합한 파일 형태라고 불 수 있다.  
예를 들어 한시간에 한번씩 RDB파일을 생성할 수 있으며, 장애 발생시 원하는 시점으로 데이터를 복원할 수 있다.  
RDB 파일이 저장될 때마다 언격 저장소로 파일을 옮겨 2차 백업을 수행한다면 데이터 센터 장애 등 더 큰 장애에도 대처할 수 있다.  

하지만 장애가 발생했을 때 손실 가능성을 최소화해야 하는 서비스에는 RDB 파일을 이용한 백업만 사용하는 것은 적절하지 않다.  
사용자가 지정한 시간 단위로 파일이 저장되기 때문에 저장 시점부터 장애가 발생한 시점까지의 데이터는 손실될 수 있다는 것을 알아둬야한다.  

## RDB 파일을 생성할 수 있는 방법
RDB 파일을 생성할 수 있는 방법은 크게 세 가지가 있다.

### 특정 조건에 자동으로 RDB 파일 생성
```redis
save <기간(초>> <기간 내 변경된 키의 개수>
dbfilename <RDB 파일 이름>
dir < RDB 파일이 저장될 경로>
```
레디스의 설정 파일에서 save 옵션을 사용해 원하는 조건에 RDB 파일을 저장하도록 설정할 수 있다.  
일정한 기간 동안 변경된 키의 개수가 조건에 맞을 때 레시드 서버는 자동으로 RDB 파일을 저장한다. RDB 파일은 dbfilename 옵션에 지정된 이름으로 생성되며 
기본 값은 dump.rdb이다. 파일은 dir에 지정한 경로에 저장된다.

```redis
save 900 1
save 300 10
save 50 10000
```
redis.conf 에 위와 같은 조건으로 save 옵션을 설정한다면 인스턴스는 다음과 같은 상황에서 RDB파일을 생선한다.
- 900초(15분) 동안 1개 이상의 키가 변경된 경우
- 300초(5분) 동안 10개 이상의 키가 변경된 경우
- 60초(1분) 동안 10000개 이상의 키가 변경된 경우

만약 RDB파일을 저장하고 싶지 않다면 save "" 와 같이 빈 문자열로 설정해서 옵션을 비활성화할 수 있다. 
이미 레디스 인스턴스가 실행 중인 상태에서 RDB 저장을 비활성화 하고 싶다면 CONFIG SET 커맨드를 이용해 save 파라미터를 ""로 초기화시키면 된다.
```redis
# 현재 적용된 save 옵션 확인
config get save
1) "save"
2) "3600 1 300 100 60 10000"

# save 옵션 초기화
CONFIG SET save ""

# 현재 적용된 save 옵션 확인
config get save
1) "save"
2) ""

# redis.conf 파일 재작성
CONFIG REWRITE
```

## 수동으로 RDB 파일 생성
save나 bgsave 커맨드를 이용하면 원하는 시점에 직접 RDB 파일을 생성할 수 있다.  
두 커맨드 모두 실행 시점의 메모리 스냅샷을 생성하는 커맨드 이지만 동작하는 방식에 차이가 있다.  
save는 동기 방식으로 파일을 저장한다.  
save 커맨드를 실행하면 파일 생성이 완료될 때까지 다른 모든 클라이언트의 명령을 차단한다.  
메모리 전체를 스캔해 파일이 저장되기 까지 1분이 걸린다면 그 1분 동안 레디스 인스턴스에 연결된 다른 클라이언트는 아무런 명령도 수행할 수 없는 상황을 맞게 된다.  
따라서 일반적인 운영 환경에서는 save 커맨드를 되도록 사용하지 않는 것이 좋다.  

bgsave는 fork를 호출해 자식 프로세스를 생성하며 생성된 자식 프로세스가 백그라운드에서 RDB 파일을 생성한 뒤 종료 된다.  
레디스를 이용하는 다른 클라이언트는 원래대로 부모 프로세스를 이용해서 처리되기 때문에 파일 저장에는 영향을 받지 않는다.  
만약 이미 백그라운드로 데이터가 저장되고 있을 때 이 커맨드를 수행하면 에러를 반환한다.  
이런 상황에서는 bgsave와 함께 schedule 옵션을 사용할 수 있는데 
이미 파일이 백그라운드에서 저장 중일 때 이 커맨드를 입력받은 레디스는 일단 ok를 반환한뒤 
기존에 진행 중이던 백업이 완료됐을 때 다시 bgsave를 실핸한다.  

RDB 파일이 정상적으로 저장됐는지는 lastsave 커맨드로 확인할 수 있으며 마지막으로 RDB 파일이 저장된 시점을 뉴닉스 타임스탬프로 반환한다.

## 복제를 사용할 경우 자동으로 RDB 파일 생성
복제본에서 replicaof 커맨드를 이용해 복제를 요청하면 마스터 노드에서는 RDB 파일을 새로 생성해 복제본에 전달한다.  
혹은 이미 복제 연결이 돼 있는 상태에서 네트워크 등의 이슈로 인해 일정 시간 이상 복제가 끊엊졌다가 복구된 경우 복제 재연결이 방생하며, 
이럴 경우에도 마스터 노드는 복제본으로 RDB 파일을 전송한다.  
따라서 복제 연결을 처음 시작했을 때뿐만 아니라 이미 복제 연결이 돼 있는 상태에서도 상황에 따라 마스터에서는 언제든지 RDB 파일을 재생성할 수 있다.  

## AOF 방식의 데이터 백업
AOF는 레디스 인스턴승서 수행된 모든 쓰기 작업의 로그를 차례로 기록한다.  
실수로 flushall 커맨드로 데이터를 모두 날려버렸다 해도 AOF 파일을 직접 열어 flushall 커맨드만 삭제한 뒤 레디스를 재시작시킨다면 커맨드를 실행하기 직전까지로 데이터를 바로 복구할 수 있다.  

설정 파일에서 appendonly 옵션을 yes로 지정하면 AOF 파일에 주기적으로 데이터가 저장된다. AOF 파일은 appenddirname에서 지정한 경로와 appendfilename 옵션에 설정한 이름으로 생성된다.
```redis
appendonly yes
appendfilename "appendonly.aof"
appenddirname "appendonlydir"
```

appendfilename 옵션을 이용해 aof 파일명을 변경하지 않는다면 기본적으로 aof 파일은 appendonly.aof 라는 이름으로 저장된다.  
버전 7.0 이상부터 aof 파일은 여러 개로 저장되며 인ㄴ appenddirname 옵션에서 지정된 디렉터리 하위에 저장된다.  
appenddirname 옵션에는 경로가 아닌 디렉터리 이름만 지정할 수 있으며 dir 옵션하위에 생성된다.
```redis
set key1 apple
set key1 beer
del key1
del non_existing_key
```
위 예제에서 첫 번째부터 세 번째 까지의 커맨드는 레디스 서버의 메모리에 영향을 끼치는 작업이고
네 번째 커맨드는 존재하지 않는 키를 삭제하는 작업이기 때문에 메로리가 수정되는 작업은 아니다.
AOF 파일에는 메모리상의 데이터가 변경되는 커맨드만 기록되기 때문에 마지막의 DEL non_existing_key 작업은 기록되지 않는다.  

AOF에서 모든 커맨드의 실행 내역은 다음과 같이 레디스 프로토콜 형식으로 저장된다.
```redis
*3
$3
set 
$4
key1
$5
apple
*3
$3
set
$4
key1
$4
beer
*2
$3
del
$4
key1
```
하지만 항상 aof 파일이 사용자가 실행한 커맨드를 그대로 저장하는 것은 아니다.  
예를 들어 list에서 블로킹 기능을 지원하는 BRPOP 커맨드는 aof 파일에 저장될 때에는 rpop로 기록된다.  
aof파일에서 블로킹 기능을 굳이 명시해줄 필요는 없기 때문이다.
```redis
rpush mylist a b c d e

brpop mylist 1
```

위의 커맨드가 실행 됐을 때 aof 파일에는 다음과 같이 기록된다.
```redis
*7
$5
rpush
$6
mylist
$1
a
$1
b
$1
c
$1
d
$1
e
*2
$4
rpop
$6
mylist
```

기존 string 값에 사용자가 입력한 부동소수점 값을 더해주는 INCRBYFLOAT 커맨드도 aof 파일에는 그대로 기록되지 않는다.
레디스가 실행되는 아키텍처에 따라 부동소수점을 처리하는 방식이 다를 수 있기 때문에 aof 파일에는 증분 후의 값을 직접 set하는 커맫느로 변경돼 처리된다.  

aof 는 append-only-file 이라는 이름 뜻 그대로 실행되는 커맨드가 파일의 뒤쪽에 계속 추가되는 방식으로 동작한다.
따라서 인스턴스가 실행되는 시간에 비례해서 aof 파일의 크기는 계쏙 증가하게 된다.
incr 커맨드를 사용해 counter 키를 100번 증가 시키면 메모리에서 counter 키는 100이 증가된 값을 저장하고 있지만, aof 파일에서는 100번의 실행 내역이 그대로 남아 있게 된다.  

## AOF 파일을 재구성하는 방법
따라서 aof 파일을 이용한 백업 기능을 안정적으로 사용하려면 점점 커지는 파일을 주기적으로 압축시키는 재구성 작업이 필요하다.  
RDB에서와 마찬가지로 특정 조건에 자동으로 재구성되도록 설정할 수도 있으며 사용자가 원하는 시점에 커맨드를 이용해 재구성시킬수 있다.  

압축, 즉 재구성은 기존 디스크에 저장됐던 AOF 파일을 사용하는 것이 아니라 레디스 메로리에 있는 데이터를 읽어와서 새로운 파일로 저장하는 형태로 동작한다.  
설정 파일에서 기본 옵션인 aof-use-rdb-preamble yes를 no로 변경하지 않는다면이 데이터는 RDB 파일 형태로 저장한다.  
RDB 파일을 저장할 때와 마찬가지로 AOF 파일을 재구성할 때에도 fork를 이용해 자식 프로세스를 생성하며 이 자식 프로세스가 AOF 파일을 재 구성해 저장한다.  

버전 7 이전까지 AOF 파일은 하나의 파일로 관리 됐다.  
aof 파일의 앞부분은 메모리의 데이터를 읽어와 바이너리 형태로 저장한 RDB 파일이 위치한다.  
이후 레디스의 메모리를 변경한 커맨드 로그들은 RESP 형태로 RDB 파일의 뒤로 쌓이는형태로 증가한다.  

### 버전 7 이전의 AOF 파일의 재구성 과정
1. 레디스는 fork를 이용해 자식 프로세스를 생성한다. 생성된 자식 프로세스는 레디스 메모리의 데이터를 읽어와 신규로 생성한 임시 파일에 저장한다.
2. 백그라운드로 1의 과정이 진행되는 동안 레디스 메모리의 데이터가 변경된 내역의 기존의 aof 파일과 인메모리 버퍼에 동시에 저장된다.
3. 1의 aof 재구성 과정이 끝나면 인메모리 버퍼에 저장된 내용을 1의 임시 파일 마지막에 추가한다.
4. 생성된 임시 파일로 기존 aof 파일을 덮어 씌운다.

이때 2의 과정에서 rdb 파일이 저장되는 동안 데이터가 변경된 동일한 로그가 aof 파일과 인메모리 버퍼에 이중으로 저장된다.  
또한 하나의 aof 파일 내에 바이너리 형태와 resp 의 텍스트 데이터가 함께 저장돼 수동으로 aof 파일을 처리할 때 관리가 복잡할 수 있다는 단점이 있다.  

### 버전 7 이후의 AOF 파일의 재구성 과정
버전 7 이후에서는 AOF는 기본이 되는 바이너리 형태의 RDB 파일, 증가하는 resp의 텍스트 형태의 aof 파일로 나눠서 데이터를 관리한다.  
또한 현재 레디스가 바라보고 있는 파일이 어떤 것인지 나타내는 매닢스트 파일을 추가적으로 도입했으며, 매니페스트 파일은 RDB와 AOF 파일이 어떤것인지 알려주는 역할을 한다.  
세 파일 모두 설정 파일에 지정한 appendfilename 옵션에 지정한 이름으로 생성된다.  

1. 레디스 인스턴스는 fork를 이용해 자식 프로세스를 생성한다. 생성된 자식 프로세스는 레디스 메모리의 데이터를 읽어와 신규로 생성한 임시 파일에 저장한다.
2. 백그라운드로 1의 과정이 진행되는 동안 레디스의 메모리의 데이터가 변경된 내역은 신규 aof 파일에 저장된다.
3. 1의 aof 재구성 과정이 끝나면 임시 매니페스트 파일을 생성한 뒤 변경된 버전으로 매니페스트 파일 내용을 업데이트 한다.
4. 생성된 임시 맨페스트 파일로 기준 매니페스트 파일을 덮어 씌운 뒤 이전 버전의 aof, rdb 파일들을 삭제한다.

기존 버전의 2,3 과정의 비효율을 줄일 수 있어 훨씬 간단한 과정으로 데이터를 저장할 수 있다.  
aor-use-rdb-preamble 옵션에 의해 압축되는 데이터 파일은 rdb 형태로 저장된다.  
이를 no로 변경하면 베이스 파일은 *.base.rdb 형태가 아닌 *.base.aof 형태로 저장되며 저장되는 형태로 resp 프로토콜 형태의 텍스트로 변경된다.  

여기서 aof 파일의 재구성은 모두 순차 입출력만 사용하기 때문에 모든 과정이 굉장히 효율적이다.  
레디스의 서버는 복원시 순차적으로 데이터를 로드하는 용도로만 aof 파일을 사용한다.  

## 자동 AOF 재구성
```redis
auto-aof-rewrite-percentage 100
auto-aof-rewrite-min-size 64mb
```

auto-aof-rewrite-percentage 눈 aof 파일을 다시 쓰기 위한 시점을 정하기 위한 옵션이다.  
마지막으로 재구성됐던 aof 파일의 크기와 비교해 현재의 aof 파일이 지정된 퍼센트만큼 커졌을 때 재구성을 시도한다.  
마지막으로 저장된 aof 파일의 크기는 레디스에서 INFO Persistence 커맨드를 이용해 확인할 수 있다.(aof_base_size)
```redis
INFO Persistence
# Persistence
aof_current_size: 100
aof_base_size: 100
```
aof_base_size가 100이고 aof_current_size가 100이다.  
auto-aof-rewrite-percentage가 100으로 설정돼 있다면 aof_current_size가 aof_base_size의 100%만큼 커졌을 때 재구성을 시도한다.  

데이터가 아무것도 없는 상태로 인스턴스가 처음 부팅됐을 때의 aof_base_size는 0이므로이럴 때에는 auto_aof_rewrite_min_size를 기준으로 데이터를 재구성한다.  
auto-aof-rewrite-min-size 옵션은 재구성된 이후의 aof 파일의 최소 크기를 지정할 수 있다.  

## 수동 AOF 재구성
bgrewriteaof 커맨드를 이용하면 원하는 시점에 직접 aof 파일을 재구성할 수 있다.  

### AOF 타임 스탬프
버전 7 이상부터는 aof를 저장할 때 타임스탬프를 남길 수 있다.  
```redis
aof-timestamp-enabled no
```

설정 파일에서 aof-timestamp-enabled 옵션을 활성화하면 aof 파일에 저장된 커맨드의 실행 시간을 기록한다.  
이를 이용하면 수동으로 aof 파일을 조작하지 않아도 시스템상에서 시점 복원이 가능하다.  

만약 사용자의 실수로 flushall 커맨드를 사용해 레디스의 모든 데이터를 삭제했다고 가정한다.  
레디스에서 제공하는 redis-check-aof 프로그램을 사용해 flshall이 실행되기 전까지로 데이터를 복구할 수 있다.
```shell
redis-check-aof --turncate-to-timestamp 1234567890 aof_file_dir/aof_file_name
```

위 과정이 끝난 후 실제로 appendonly.aof.15.incr.aof 파일을 확인해보면 flashall 커맨드가 수행되기 전까지의 데이터만 aof 파일에 남아 있게 된다.  
이때 turncate-to-timestamp 옵션을 사용해 aof 파일을 복구하면 원본 파일이 변경된다.  
작업을 수행하기 이전의 aof 파일을 보호하고 싶으면 원본 파일을 미리 다른 곳에 복사해 두는 것이 좋다.  

## aof 파일 복원
시점 복원에서 사용한 redis-check-aof 프로그램은 aof 파일이 손상됐을 때에도 사용할 수 있다.  
의도치 않은 서버의 장애 발생시 aof 파일 작성 도중 레디스가 중지 됐을 가능성이 존재한다.
```redis
redis-check-aof --fix aof_file_dir/aof_file_name(name.aof.manifast)
```
레디스가 비 정상적으로 중단됐을 때 redis-check-aof 프로그램을 사용하면 aof 파일 상태가 정상적인지 확인할 수 있다.  
위와 같은 경우 RDB 파일은 정상이며, aof 파일은 비정상이니 fix 옵션을 사용하며 해결하라는 문구가 나온다.

## AOF 파일의 안정성
### 운영체제에서 시스템콜을 이용해 데이터를 파일에 저장하는 방벙
운영체제에서 애플리케이션이 파일에 데이터를 저장하고자 할 때 곧바로 디스크에 데이터가 저장되진 않는다.  
write라는 시스템 콜을 이용해 애플리케이션에서 파일에 데이터를 저장하겠다 하면 데이터는 커널 영역의 OS 버퍼에 임시로 저장된다.  
운영체제가 판단하기에 커널이 여유 있거나 최대 지연 시간인 30초에 도달하면 커널 버퍼의 데이터를 실제로 디스크에 내려 쓴다.  

FSYNC는 커널의 OS 버퍼에 저장된 내뇽을 실제로 디스크에 내리도록 강제하는 시스템 콜이다.  
OS에 부하가 있더라도 FSYNC가 호출되면 데이터는 무조건 디스크에 풀러시된다.  

레디스에서 AOF 파일을 저장할 때 APPENDFSYNC 옵션을 이용하면 FSYNC 호출을 제어할 수 있으며, 즉 파일의 내구성을 제어할 수 있다.  

- APPENDFSYNC NO : wirte 시스템 콜을 호출한다. 데이터는 커널영역에 데이터가 잘 저장되는지만 확인하기 때문에 쓰기 성능이 가장 빠르다.
- APPENDFSYNC always: aof 데이터를 저장할 때 항상 write와 fsync 시스템콜을 함께 호출한다. 즉 매번 쓰고자 하는 데이터가 파일에 정확하게 저장디는 것을 기다리기 땜ㄴ에 성능은 가장 느리다.
- APPENDFSYNC everysec: wirte 시스템 콜을 호출하며 1초에 한번씩 fsync 시스템 콜을 호출한다. 성능은 no 옵션을 사용할때와 거의 비슷하다.  

기본 옵션은 everysec로, no 옵션과 비슷한 성능을 가지면서 서버 장애가 발생했을때 유실될 수 있는 데이터가 1초이기 때문에
속도와 안정성의 균형을 맞출 수 있는 값이다.  

## 백업을 사용할 때 주의할점
RDB, AOF 파일을 사용하는 경우 인스턴스의 maxmemory 값을 실제 서버 메모리보다 여유를 갖고 설정하는 것이 좋다.  
BGSAVE 커맨드로 RDB 파일을 저장하거나 AOF 재구성을 진행할 때 레디스는 fork()를 이용해 자식 프로세스를 생성한다.  
생성된 자식 프로세스는 레드스의 메모리를 그대로 파일에 저장하며 기존의 부모 프로세스는 다른 메모리의 데이터를 이용해 다른 클라이언트의 연결을 처리해야한다.  
이때 레디스는 Copy-on-Write 방식을 이용해 메모리상의 데이터를 하나 더 복사하는 방법을 이용해 백업을 진행하면서도 클라이언트의 요청 사항을 받아 메모리의 데이터를 읽고 수정하는 작업을 진행할 수도 있다.  

물리적 메모리에 있는 실제 메로리 페이지가 그대로 복제되기 때문에 최악의 경우 레디스는 기존 메모리 용량의 2배를 사용하게 될 수도 있다.  
레디스의 maxmemory 값을 너무 크게 설정한 경우 레디스의 copy-on-write 동작으로 인해 OS 메모리가 가득 차는 상황이 발생할 수 있으며, 이로 인해 OOM 문제로 서버가 다운될 수 있다.
따라서 레디스의 maxmemory 옵션은 실제 메모리보다 여유를 갖고 설정하는 것이 안정적이다.  

|RAM| Maxmemory | 비율  |
|---|-----------|-----|
|2GB| 638MB     | 33% |
|4GB| 2048MB    | 50% |
|8GB| 4779MB    | 58% |
|16GB| 10240MB   | 63% |
|32GB| 21163MB   | 65% |
|64GB| 43008MB   | 66% |

RDB 스냅샷을 저장하는 도중엔 AOF의 재구성 기능을 사용할 수 없고 AOF 재구성이 진행될 때에는 BGSAVE를 실행할 수 없다.
