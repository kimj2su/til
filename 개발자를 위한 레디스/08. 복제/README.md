가용성은 일반적으로 서비스의 안정성을 측정하는 데 사용되는 지표다.  
가용성이란 일정 기간 동안 서비스를 정상적으로 사용할 수 있는 시간의 비율을 뜻하며, 이 값이 클수록 가용성이 높다고 한다.  
가용성이 높은 시스템을 고가용성 시스템이라고 부른다.  

레디스에서 고가용성을 확보하기 위해서는 다음의 두 가지 기능이 필요하다.
- 복제 : 마스터 노드의 데이터를 복제본 노드로 실시간 복사하는 기능이다. 마스터 노드의 서버에 장애가 생겨 데이터가 유실된다 해도 복제본 노드에서 데이터를 확인할 수 있다.
- 자동 페일오버 : 마스터 노드에서 발생한 장애를 감지해 레디스로 들어오는 클라이언트 연결을 자동으로 복제본 노드로 리다이렉션하는 기능이다.


# 레디스에서의 복제 구조
대부분의 데이터 저장소 애플리케이션은 자체적으로 복제 기능을 제공한다.  
운영중인 서비스에서 복제본 노드를 추가하는 이유는 대부분 다음과 같다.  

- 애플리케이션이 실행 중인 하드웨어는 언제든지 고장날 수 있으므로, 서비스를 안정적으로 운영하기 위해서는 마스터 데이터베이스가 다운됐을 때 대신 사용할 여분의 복제본이 필요하다.
- 대규모 서비스에서 복베본은 트래픽을 감소시키는 역할을 수행할 수 있다. 실시간으로 마스터 노드에 접근해 데이터를 가져가는 서비스가 많을 때, 일부 트래픽이 복제본을 바로보게
한다면 부하 분산을 통해 마스터 노드로의 트래픽을 줄일 수 있게 된다.
- 운ㅇ녕중인 마스터노드에서 매번 데이터의 백업을 받는 것은 부담스러운 작업이다.
백업을 복제본에서 수행하면 백업 작업이 서비스에 미치는 영향도를 최소화할 수 있다.

복제 노드는 읽기 전용으로 동작하기 때문에 데이터를 읽는 커맨드만 수행할 수 있다.  
모든 데이터의 입력은 마스터 노드에서 이뤄지는게 일반적이며, 복베본은 마스터에서 변경된 데이터를 그대로 받아온다.  

## 복제 구조 구성하기
```redis
replicaof <master-ip> <master-port>
```
복제본이 될 노드 B에서 replicaof 커맨드를 입력해 마스터 노드의 정보를 입력하면 복제 연결이 시작된다.  
레디스의 데이터를 업데이터하는 모든 커맨드는 노드 A에서 실행되기 때문에 서비스 애플리케이션은 노드 A를 바라봐야한다.  
마스터 A가 다운되면 애플리케이션의 연결 설정을 B로 변경하면된다.  
마스터는 무조건 하나고 여러개의 복제본이 연결될 수 있다.

## 패스워드 설정
6.0부터 도입된 ACL 기능이 아닌 기본적인 패스워드를 사용해서  데이터를 복제할 때에는 masterauth 옵션에 패스워드를 입력해야 한다.  
ACL 기능은 11장에서 설명함.  

레디스에서는 requirepass 옵션으로 패스워드 설정 할 수 있다.  
복제본 노드에는 masterpass 옵션에 requirepass에 설정된 패스워드 값을 입력해야한다.  

하나의 복제 긃에 속한 마스터와 복제본 노드는 같은 패스워드를 설정하는 것이 일반적이다.
```redis
config set masterauth <password>

config rewrite # 설정을 다시 읽어들인다.
```

## 복제 메커니즘
레디스에서 복제는 다음 메커니즘으로 동작한다.  
다음의 모든 과정은 자동으로 이뤄지며 사용자의 개입이 필요하지 않다.  

레디스 7 버전 이후 부터는 repl-diskless-sync 옵션의 기본값은 yes다. 이스크를 사용하지 않는 방식에서 복제가 이뤄진다.  

1. replicaof 커맨드로 복제 연결을 시도한다.
2. 마스터 노드는 소켓 통신을 이용해 복제본 노드에 바로 연결하며, RDB 파일은 생성됨과 동시에 점진적으로 복제본의 소켓에 전송된다.
3. 2의 과정 동안 마스터 노드에서 수행된 모든 데이터 셋 변경 작업은 레디스 프로토콜 형태로 마스터의 복제 버퍼에 저장된다.
4. 소켓에서 읽어온 RDB 파일을 복제본의 디스크에 저장한다.
5. 복제본에 저장된 모든 데이터를 모두 삭제한 뒤 RDB 파일 내용을 메모리에 로딩한다.
6. 복제 버퍼의 데이터를 복제본으로 전달해 수행시킨다.

복제본의 repl-diskless-load 옵션은 기본으로 disabled이기 때문에 소켓에서 읽어온 RDB 스냅숏 데이터를 바로 메모리에 로드하지 않고
일단 복제본 노드의 디스크에 저장하는 과정을 거친다.
복제본 노드는 마스터에서 가져온 데이터를 불러오기전에 자신의 데이터를 모두 삭제하는 과정을 거쳐야하는데 이때 소켓 통신으로 받아온 RDB 데이터가 정상적인지를 미리 확인할 수 없기 때문에
모두 삭제하기전 자신의 디스크에 저장하는 과정을 선택함으로 데이터의 안정성을 확보할 수 있다.  

디스크를 사용하지 않는 방식에서는 하나의 복제본으로 복제 연결이 시작된 경우에는 복제 과정이 끝나기 전까지 다른 복제본과의 연결은 수행될 수 없으며,
다른 복제본들은 하나의 복제 연결이 끝날때까지 큐에서 대기해야 한다.
이를 방지하기 위해 repl-diskless-sync-delay 옵션을 사용할 수 있다.

```redis
repl-diskless-sync-delay 5 
```
이 값의 기본값은 5초로 새로운 복제 연결이 들어오면 기본 5초를 기다린 뒤 복제 연결을 시작한다는 의미이다.

## 비동기 방식으로 동작하는 복제 연결
정상적으로  복제 연결이 된 상태에서 마스터에서 복제본으로의 데이터 전달을 비동기 방식으로 동작한다.  
클라이언트가 마스터 노드에 set a b라고 커맨드가 수행되면 레디스는 마스터 노드에서 처리한 후 ok를 반환한다.  
복제본에 데이터를 정확하게 전달됐는지 확인하는 과정을 거치지 않아 짧은 지연시간과 높은 성능을 갖게 된다.  
이후 복제본에 전달되지 않은 상태에서 마스터 노드에 장애 상황이 발생된다면 데이터 유실가능성이 있다.  
하지만 복제본에 전달도는 속도는 굉장히 빠르기 때문에 데이터의 유실이 빈번하게 발생되진 않는다.

## 복제 ID
모든 레디스 인스턴스는 복제 ID(Replication ID)를 가지고 있다.  
복제 기능을 사용하지 않는 인스턴스라도 모두 랜덤 스트링 값의 복제 ID를 가지며, 복제 ID는 오프셋과 쌍으로 존재한다.
레디스 내부의 데이터가 수정되는 모든 커맨드를 수행할 때마다 오프셋이 증가한다.

INFO REPLICATION 커맨드를 사용하면 복제 연결 상태를 확인할 수 있다.
```redis
role:master
connected_slaves:0
master_failover_state:no-failover
master_replid:6decfff383ba486b43a8d2ca2277bfe1af3424d5
master_replid2:0000000000000000000000000000000000000000
master_repl_offset:0
second_repl_offset:-1
repl_backlog_active:0
repl_backlog_size:1048576
repl_backlog_first_byte_offset:0
repl_backlog_histlen:0
```
인스턴스의 역할은 마스터이며 연결된 복제본은 없다는 것을 알 수 있다.  
또한 복제본 ID는 6decfff383ba486b43a8d2ca2277bfe1af3424d5, 오프셋은 0이라는 정보도 확인할 수 있다.  
이 마스터 노드에 복제본을 연결한 뒤 다시 INFO REPLICATION 커맨드를 사용해 정보를 확인하면  
connected_slaves:1로 변경되고, 복제본의 정보가 추가된 것을 확인할 수 있다.  
복제본에서 확인하면 role:slave로 변경되고, master_replid와 master_repl_offset에 마스터 노드의 정보가 추가된 것을 확인할 수 있다.  
오프셋은 복제본에서 마지막으로 수행된 마스터의 오프셋을 의미한다.  

만약 마스터 노드의 오프셋이 807이고 복제본이 801이라면 아직 802~807까지의 데이터가 복제본에 전달되지 않았다는 것을 의미한다.  
레디스에서 replication id와 오프셋이 같을 때 두 노드는 정확히 일치된 상태라는 것을 의미한다.

## 부분 재동기화
복제 연결이 끊길 때마다 마스터에서 RDB 파일을 새로 내려 복제본에 전달하는 과정을 거친다면 네트워크가 불안정한 상황에서 복제 기능을 사용하는 레디스의 성능은 급격하게 나빠질 것이다.  
이를 방지하기 위해 레디스는 부분 재동기화기능을 사용해 안정적으로 복제 연결을 유지한다.  

마스터는 커넥션 유실을 대비해 백로드 버퍼라는 메모리 공간에 복제본에 전달한 커맨드 데이터들을 저장해둔다.  
하나의 복제 그룹에서 replication id와 오프셋을 이용하면 복제본이 마스터의 어느 시점까지 데이터를 가지고 있는지 파악할 수 있다.  
만약 복제 연결이 잠시 끊긴 뒤 재연결하면 복제본은 PSYNC 커맨드를 호출해 자신의 replication id와 오프셋을 마스터에 전달한다.  

만약 마스터 백로그에 901~915의 데이터가 저장되어 있다면 RDB 파일을 저장하지 않고 901~915의 데이터를 복제본에 전달한다.  
하지만 마스터 백로그에 원하는 데이터가 남아 있지 않거나 복제본이 보낸 replication ID가 현재의 마스터와 일치하지 않다면 전체 재동기화를 시도한다.  

복제 백로그 크기는 repl-backlog-size 옵션으로 설정할 수 있다. -> 기본 값음 1MB이다.  
백로그 크기가 클수록 복제본이 부분 재동기화를 수행할 수 있는 시간이 길어진다.  
백로그는 1개 이상의 복제본이 연결된 경우에만 할당되며 repl-backlog-ttl 만큼의 시간이 경과하면 메모리에서 백로그 공간을 삭제한다.  

복제본은 언제든지 마스터로 승격할 수 있는 가능성을 갖고 있기 때문에 복제본에 직접 연결된 복제 연결이 따로 없더라고 백로그 버퍼를 해제하지 않는다.  

## Secondary Replication ID
A 노드에 장애가 발생해 복제가 끊기도 복제본 B가 새로운 노드로 승격되는 상황을 가정한다.  

마스터 노드와의 복제가 끊어짐과 동시에 복제본은 새로운 복제 ID를 갖게 된다.  
만약 A - B 가 aaaa라는 복제 ID를 유지하며 마스터로 동작하다가 장애가 해결된 뒤 기존 마스터였던 A와 다시 연결된다면 두 노드는 동일한 복제 ID,
동일한 오프셋이 동일한 데이터셋을 갖는다는 사실을 위반할수 있기 때문이다.  
새로운 복제 ID인 bbbb를 갖게 되며 기존의 복제 ID는 master_replid2에 저장된다.  

노드 C가 B에 복제 연결이 될때, 두 노드의 master_replid2가 같기 때문에 C노드는 B노드에 부분 재동기화를 시도한다.  
레디스가 2개의 복제 ID를 갖는 이유는 마스터로 승격되는 복제본 때문이며,
같은 복제 그룹 내에서 페일 오버 이후 승격된 새로운 마스터에 연결된 복제본은 전체 재동기화를 수행할 필요가 없을 수 있다.

## 읽기 전용 모드로 동작하는 복제본 노드
2.6이후 복제를 구성하면 복제본은 기본으로 읽기 전용 모드로 동작한다.  

특정 상황에서 마스터 노드에서 수행하기에는 오래 걸리는 연산의 결과를 테스트하기 위한 용도로 복제본의 replica-read-only 설정을 해제하고 싶을 수 있다.  
이 경우 복제본 노드의 데이터가 변경되더라도 복제본이 재시작되거나 커넥션이 유실돼 마스터와 전체 재동기화를 수행하게 되면 복제본에서 수행한 데이터는 데이터는 사라지기 때문에 유의해야한다.  

복제본에 직접 데이터를 쓸 수 있다 하더라도 다른 복제본에 전파되지 않고 로컬에만 존재한다.

## 유효하지 않은 복제본 데이터
복제 구조에서 유효하지 않은 데이터란 복제본의 데이터와 마스터의 데이터가 정확하게 일치하지 않는 경우의 데이터를 의미한다.  
레디스에서 복제본이 마스터와 연결이 끊어진 상태, 혹은 복제 연결이 시작된 뒤 아직 완료 되지 않았을 경우에 복제본의 데이터가 유효하지 않다고 판단할수 있다.  

복제본의 데이터가 유효하지 않다고 판단될 때 복제본의 동작 방식은 replica-server-stale-data 파라미터를 이용해 제어할 수 있다.  
기본값은 yes로 복제본의 데이터가 유효하지 않다고 판단될 때에도 클라이언틀부터 들어오는 모든 읽기 요청에 데이터를 반한한다.  
이 값을 no로 설정한다면 INFO, CONFIG, PING 등의 일부 기본 커맨드에 대해 SYNC with master in progress라는 오류를 반환한다.

## 백업을 사용하지 않는 경우에서의 데이터 복제
레디스에서 복제를 사용하는 경우 마스터와 복제본에서 백업 기능을 사용하는 것이 좋다.  
만약 이 기능을 사용하지 않으려면 재부팅 후 레디스가 자동으로 재시작 되지 않도록 설정할 것을 권장한다.

1. 백업 기능을 사용하지 않는 마스터와 복제본 노드가 존재한다.
2. 마스터 노드가 장애로 인해 종료됐지만 레디스 프로세스를 자동 재시작하는 시스템에 의해 노드가 재부팅된다. 이때 메모리의 내용은 초기화된다.
3. 복제본 노드에는 데이터가 존재하지만 마스터 노드로의 복제 연결을 시도한다.
4. 마스터에서 복제본으로 빈 데이터셋을 전달한다.

만약 백업을 사용했다면 2번 상황에서 레디스가 잽팅될때 백업 파일을 자동으로 읽어오기 때문에 데이터가 복원되며 복원된 내용이 복제본으로 전달된다.  

자동 재시작 기능을 사용하지 않았다면 복제본 노드에는 데이터가 존재하기 때문에 애플리케이션 연결 설정을 마스텅서 복제본 노드로 변경해 데이터를 계속 사용할 수 있다.  
혹은 복제본 노드에서 데이터를 새로 백업 받아 마스터 노드에 전달한 뒤 마스터 노드를 시작시키면 복제본 노드에 저장된 내용으로 데이터가 복원될 수 있다.  

따라서 데이터의 안정성을 위해 복제 기능을 사용할 경우 백업 기능을 사용하는 것이 좋으며, 그렇지 않을 경우 마스터에서는 인스턴스의 자동 재시작을 활성화 하지 않는 것을 권장한다.
